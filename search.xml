<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker、消息队列</title>
      <link href="/2022/04/22/Docker%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2022/04/22/Docker%E3%80%81%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Docker"><a href="#1-Docker" class="headerlink" title="1. Docker"></a>1. Docker</h1><p><code>Docker</code> 是世界领先的软件容器平台<br><strong>容器就是将软件打包成标准化单元，以用于开发、交付和部署。</strong></p><ul><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于基于 <code>Linux</code> 和 <code>Windows</code> 的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。<br><img src="https://img-blog.csdnimg.cn/f23576702a8e4a57ace14bfdbc63324d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_10,color_FFFFFF,t_70,g_se,x_16" alt="容器"><br><strong>容器</strong>虚拟化的是<strong>操作系统</strong>而不是硬件，容器之间是共享同一套操作系统资源的。<br><strong>虚拟机</strong>技术是虚拟出一套<strong>硬件</strong>后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</li></ul><h1 id="2-再来谈谈-Docker-的一些概念"><a href="#2-再来谈谈-Docker-的一些概念" class="headerlink" title="2. 再来谈谈 Docker 的一些概念"></a>2. 再来谈谈 Docker 的一些概念</h1><h2 id="1-什么是-Docker？"><a href="#1-什么是-Docker？" class="headerlink" title="1. 什么是 Docker？"></a>1. 什么是 Docker？</h2><ul><li><code>Docker</code> 是世界领先的软件容器平台。</li><li><code>Docker</code> 使用 Google 公司推出的 <code>Go</code> 语言 进行开发实现，基于 <code>Linux</code> 内核 提供的 <code>CGroup</code> 功能和 <code>namespace</code> 来实现的，以及 <code>AUFS</code> 类的 <code>UnionFS</code> 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</li><li><code>Docker</code> 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。</li><li>用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。<h2 id="2-Docker-思想"><a href="#2-Docker-思想" class="headerlink" title="2. Docker 思想"></a>2. Docker 思想</h2></li><li>集装箱</li><li>标准化： ① 运输方式 ② 存储方式 ③ API 接口</li><li>隔离<h2 id="3-Docker-容器的特点"><a href="#3-Docker-容器的特点" class="headerlink" title="3. Docker 容器的特点"></a>3. Docker 容器的特点</h2></li><li><strong>轻量</strong> : 在一台机器上运行的多个 <code>Docker</code> 容器可以共享这台机器的操作系统内核；它们能够迅速启动，只需占用很少的计算和内存资源。镜像是通过文件系统层进行构造的，并共享一些公共文件。这样就能尽量降低磁盘用量，并能更快地下载镜像。</li><li><strong>标准</strong> : <code>Docker</code> 容器基于开放式标准，能够在所有主流 <code>Linux</code> 版本、Microsoft Windows 以及包括 <code>VM</code>、裸机服务器和云在内的任何基础设施上运行。</li><li><strong>安全</strong> : <code>Docker</code> 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。<h2 id="4-为什么要用-Docker？"><a href="#4-为什么要用-Docker？" class="headerlink" title="4. 为什么要用 Docker？"></a>4. 为什么要用 Docker？</h2></li><li>一致的运行环境</li><li>更快速的启动时间</li><li>隔离性</li><li>弹性伸缩，快速扩展</li><li>迁移方便</li><li>持续交付和部署<h1 id="3-容器-VS-虚拟机"><a href="#3-容器-VS-虚拟机" class="headerlink" title="3. 容器 VS 虚拟机"></a>3. 容器 VS 虚拟机</h1><h2 id="1-对比"><a href="#1-对比" class="headerlink" title="1. 对比"></a>1. 对比</h2>容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为<strong>容器虚拟化的是操作系统</strong>，而不是硬件，因此容器更容易移植，效率也更高。<br><img src="https://img-blog.csdnimg.cn/fc69f4374e0c4fabb91e999c32838cdd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="vm容器"><h2 id="2-容器与虚拟机总结"><a href="#2-容器与虚拟机总结" class="headerlink" title="2. 容器与虚拟机总结"></a>2. 容器与虚拟机总结</h2><img src="https://img-blog.csdnimg.cn/909cc6a648e441a48d2ec386805f7e0e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="总结"></li><li><strong>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行</strong> 。与虚拟机相比， <strong>容器占用的空间较少</strong>（容器镜像大小通常只有几十兆），<strong>瞬间就能完成启动</strong> 。</li><li><strong>虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。</strong> 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 <strong>占用大量空间</strong> 。而且 <strong>VM 启动也十分缓慢</strong> 。<h1 id="4-Docker-基本概念"><a href="#4-Docker-基本概念" class="headerlink" title="4. Docker 基本概念"></a>4. Docker 基本概念</h1>Docker 中有非常重要的三个基本概念，理解了这三个概念，就理解了 Docker 的整个生命周期。</li><li><strong>镜像（Image）</strong></li><li><strong>容器（Container）</strong></li><li><strong>仓库（Repository）</strong><h2 id="1-镜像-Image-：一个特殊的文件系统"><a href="#1-镜像-Image-：一个特殊的文件系统" class="headerlink" title="1. 镜像(Image)：一个特殊的文件系统"></a>1. 镜像(Image)：一个特殊的文件系统</h2><strong>镜像就是一个只读的模板，镜像可以用来创建 Docker 容器，一个镜像可以创建多个容器</strong><br>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。 <h2 id="2-容器-Container-：镜像运行时的实体"><a href="#2-容器-Container-：镜像运行时的实体" class="headerlink" title="2. 容器(Container)：镜像运行时的实体"></a>2. 容器(Container)：镜像运行时的实体</h2><strong>容器是镜像运行时的实体</strong>。<br>容器可以被创建、启动、停止、删除、暂停等 。<br>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。前面讲过镜像使用的是分层存储，容器也是如此。</li></ul><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong> ，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此， <strong>使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失</strong>。</p><h2 id="3-仓库-Repository-：集中存放镜像文件的地方"><a href="#3-仓库-Repository-：集中存放镜像文件的地方" class="headerlink" title="3. 仓库(Repository)：集中存放镜像文件的地方"></a>3. 仓库(Repository)：集中存放镜像文件的地方</h2><p><strong>仓库是集中存放镜像文件的场所。</strong><br>镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一个镜像就代表一个<strong>软件</strong>；而基于某个镜像运行就是生成一个<strong>程序实例</strong>，这个程序实例就是容器；而仓库是用来<strong>存储</strong> Docker 中所有镜像的。</p><h1 id="5-常见命令"><a href="#5-常见命令" class="headerlink" title="5. 常见命令"></a>5. 常见命令</h1><h2 id="1-基本命令"><a href="#1-基本命令" class="headerlink" title="1. 基本命令"></a>1. 基本命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker version # 查看docker版本</span><br><span class="line">docker images # 查看所有已下载镜像，等价于：docker image ls 命令</span><br><span class="line">docker container ls #查看所有容器</span><br><span class="line">docker ps #查看正在运行的容器</span><br><span class="line">docker image prune # 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span><br></pre></td></tr></table></figure><h2 id="2-拉取镜像"><a href="#2-拉取镜像" class="headerlink" title="2. 拉取镜像"></a>2. 拉取镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql <span class="comment"># 查看mysql相关镜像</span></span><br><span class="line">docker pull mysql:<span class="number">5.7</span> <span class="comment"># 拉取mysql镜像</span></span><br><span class="line">docker image <span class="built_in">ls</span> <span class="comment"># 查看所有已下载镜像</span></span><br></pre></td></tr></table></figure><h2 id="3-删除镜像"><a href="#3-删除镜像" class="headerlink" title="3. 删除镜像"></a>3. 删除镜像</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ docker <span class="built_in">ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">c4cd691d9f80        mysql:<span class="number">5.7</span>           <span class="string">&quot;docker-entrypoint.s…&quot;</span>   <span class="number">7</span> weeks ago         Up <span class="number">12</span> days          <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">3306</span>-&gt;<span class="number">3306</span>/tcp, <span class="number">33060</span>/tcp   mysql</span><br><span class="line"></span><br><span class="line">➜  ~ docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mysql                   <span class="number">5.7</span>                 f6509bac4980        <span class="number">3</span> months ago        <span class="number">373</span>MB</span><br><span class="line"></span><br><span class="line">docker rmi f6509bac4980 <span class="comment">#  或者 docker rmi mysql </span></span><br></pre></td></tr></table></figure><h1 id="6-Build-Ship-and-Run"><a href="#6-Build-Ship-and-Run" class="headerlink" title="6. Build Ship and Run"></a>6. Build Ship and Run</h1><p><code>“Docker - Build, Ship, and Run Any App, Anywhere”。</code><br><strong>Build（构建镜像）</strong>：镜像就像是集装箱包括文件以及运行环境等等资源。<br><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。<br><strong>Run （运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。<br>Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。<br><img src="https://img-blog.csdnimg.cn/b3a667d9d98a4cffb453d335bf9a74cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_11,color_FFFFFF,t_70,g_se,x_16" alt="docker"></p><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><p>负载均衡系统通常用于将任务比如用户请求处理分配到多个服务器处理以提高网站、应用或者数据库的性能和可靠性。<br>常见的负载均衡系统包括 3 种：</p><ol><li><strong>DNS 负载均衡</strong>：一般用来实现地址级别的均衡。</li><li><strong>硬件负载均衡</strong>：通过单独的硬件设备比如 F5 来实现负载均衡功能（硬件的价格一般很贵）。</li><li><strong>软件负载均衡</strong>：通过负载均衡软件比如 <code>Nginx</code> 来实现负载均衡功能。<h1 id="消息队列知识点-amp-面试题总结"><a href="#消息队列知识点-amp-面试题总结" class="headerlink" title="消息队列知识点&amp;面试题总结"></a>消息队列知识点&amp;面试题总结</h1><h1 id="1-什么是消息队列？"><a href="#1-什么是消息队列？" class="headerlink" title="1. 什么是消息队列？"></a>1. 什么是消息队列？</h1>消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。<br>消息队列是分布式系统中重要的组件之一。<br>使用消息队列主要是为了<strong>通过异步处理提高系统性能和削峰、降低系统耦合性</strong>。<h1 id="2-为什么要用消息队列？"><a href="#2-为什么要用消息队列？" class="headerlink" title="2. 为什么要用消息队列？"></a>2. 为什么要用消息队列？</h1>三点好处：</li><li>通过<strong>异步处理</strong>提高系统性能（减少响应所需时间）。</li><li><strong>削峰&#x2F;限流</strong></li><li><strong>降低系统耦合性</strong>。</li></ol><p>1.1 通过<strong>异步处理</strong>提高系统性能（减少响应所需时间）。<br>使用消息队列进行异步处理之后，需要适当修改业务流程进行配合<br><img src="https://img-blog.csdnimg.cn/0296438b238946789a90435dfdd2f686.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="异步"><br>1.2 削峰&#x2F;限流<br>先将短时间高并发产生的事务消息存储在消息队列中，然后后端服务再慢慢根据自己的能力去消费这些消息，这样就避免直接把后端服务打垮掉。<br><img src="https://img-blog.csdnimg.cn/419dade57e364285a34f57c059d2352e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="削峰"><br>1.3 降低系统耦合性<br>模块之间不存在直接调用，那么新增模块或者修改模块就对其他模块影响较小，这样系统的可扩展性无疑更好一些。<br><img src="https://img-blog.csdnimg.cn/a2cb81b2f8464622affb03d8c06fd5cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="耦合性"></p><h1 id="3-使用消息队列带来的一些问题"><a href="#3-使用消息队列带来的一些问题" class="headerlink" title="3. 使用消息队列带来的一些问题"></a>3. 使用消息队列带来的一些问题</h1><ul><li><strong>系统可用性降低</strong>： 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高</strong>： 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题</strong>： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了<h1 id="4-JMS-VS-AMQP"><a href="#4-JMS-VS-AMQP" class="headerlink" title="4. JMS VS AMQP"></a>4. JMS VS AMQP</h1><h2 id="1-JMS"><a href="#1-JMS" class="headerlink" title="1. JMS"></a>1. JMS</h2><code>JMS</code>（JAVA Message Service,java 消息服务）是 java 的消息服务，<code>JMS</code> 的客户端之间可以通过 <code>JMS</code> 服务进行异步的消息传输。<code>JMS</code>（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范<br><code>ActiveMQ</code> 就是基于 JMS 规范实现的。<h2 id="2-AMQP-线路层协议"><a href="#2-AMQP-线路层协议" class="headerlink" title="2. AMQP(线路层协议)"></a>2. AMQP(线路层协议)</h2><code>AMQP</code>，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 高级消息队列协议（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。<br>RabbitMQ 就是基于 AMQP 协议实现的。<h2 id="3-JMS-vs-AMQP"><a href="#3-JMS-vs-AMQP" class="headerlink" title="3. JMS vs AMQP"></a>3. JMS vs AMQP</h2><img src="https://img-blog.csdnimg.cn/7bc20e3de3bd4a3fa38e38975df0bd6c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_18,color_FFFFFF,t_70,g_se,x_16" alt="jms amqp"><h1 id="5-常见的消息队列对比"><a href="#5-常见的消息队列对比" class="headerlink" title="5. 常见的消息队列对比"></a>5. 常见的消息队列对比</h1><img src="https://img-blog.csdnimg.cn/1f4d95e847754591a3e5de38c2516e79.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_18,color_FFFFFF,t_70,g_se,x_16" alt="消息队列对比"></li></ul><hr><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/7ed740e0857d4d3586fb750d3530c8e8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="小青"></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础知识整理</title>
      <link href="/2022/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/04/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="1-什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#1-什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h1><ol><li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。<br><img src="https://img-blog.csdnimg.cn/a708e85ac137447bb9ba340aebd9dd12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="DBMS"><h1 id="2-什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#2-什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h1><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。<br><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。<br><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。<br><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。<br><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。<br><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。<br><strong>非主属性</strong>： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。<h1 id="3-主键和外键有什么区别？"><a href="#3-主键和外键有什么区别？" class="headerlink" title="3. 主键和外键有什么区别？"></a>3. 主键和外键有什么区别？</h1><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。<br><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。<h1 id="4-为什么不推荐使用外键与级联？"><a href="#4-为什么不推荐使用外键与级联？" class="headerlink" title="4. 为什么不推荐使用外键与级联？"></a>4. 为什么不推荐使用外键与级联？</h1></li><li><strong>增加了复杂性</strong>： a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li><li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。<br>……<h1 id="5-什么是-ER-图？"><a href="#5-什么是-ER-图？" class="headerlink" title="5. 什么是 ER 图？"></a>5. 什么是 ER 图？</h1><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。<br>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。<br><img src="https://img-blog.csdnimg.cn/ac84286a88c2443db005e1b72d498784.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="E-R"><br>我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：<br><img src="https://img-blog.csdnimg.cn/18f76f763b7e4e42984f44066d85733a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="ER"><h1 id="6-数据库范式了解吗？"><a href="#6-数据库范式了解吗？" class="headerlink" title="6. 数据库范式了解吗？"></a>6. 数据库范式了解吗？</h1></li><li>1NF(第一范式)<br>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。</li><li>2NF(第二范式)<br>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。<br><img src="https://img-blog.csdnimg.cn/8ccb5bf6e0854ae7adf5cafb9780ce9d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_13,color_FFFFFF,t_70,g_se,x_16" alt="2NF"><br><strong>函数依赖</strong>（functional dependency） ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。<br><strong>部分函数依赖</strong>（partial functional dependency） ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；<br><strong>完全函数依赖</strong>(Full functional dependency) ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；<br><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z&#x3D;空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li><li>3NF(第三范式)<br>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</li></ol><p><strong>总结</strong>：</p><ul><li><code>1NF</code> ：属性不可再分。</li><li><code>2NF</code> ：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li><code>3NF</code> ：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。<h1 id="7-什么是存储过程？"><a href="#7-什么是存储过程？" class="headerlink" title="7. 什么是存储过程？"></a>7. 什么是存储过程？</h1>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</li></ul><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。<br><img src="https://img-blog.csdnimg.cn/c5834fbdf19e4b1b8bc81f81234e3388.png" alt="存储过程"></p><h1 id="8-drop、delete-与-truncate-区别？"><a href="#8-drop、delete-与-truncate-区别？" class="headerlink" title="8. drop、delete 与 truncate 区别？"></a>8. drop、delete 与 truncate 区别？</h1><ol><li>用法不同<br><code>drop(丢弃数据)</code>：<code>drop table 表名</code>，直接将表都删除掉，在删除表的时候使用。<br><code>truncate</code> (清空数据)：<code>truncate table 表名</code>，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。<br><code>delete</code>（删除数据）：<code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 where 子句和 <code>truncate table</code> 表名作用类似。<br> <code>truncate</code> 和 <code>delete</code> 只删除数据<strong>不删除表的结构</strong>(定义)，执行 <code>drop</code> 语句，此表的结构也会删除</li><li>属于不同的数据库语言<br><code>truncate</code> 和 <code>drop</code> 属于 <code>DDL</code> (数据定义语言)语句，操作立即生效，原数据不放到 <code>rollback segment</code> 中，不能回滚，操作不触发 <code>trigger</code>。而 <code>delete</code> 语句是 <code>DML</code> (数据库操作语言)语句，这个操作会放到 <code>rollback segement</code> 中，事务提交之后才生效。</li></ol><ul><li><code>DML</code> 语句和 <code>DDL</code> 语句区别：<ul><li><code>DML</code> 是数据库操作语言（Data Manipulation Language）的缩写，是指对<strong>数据库中表记录</strong>的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li><li><code>DDL</code> （Data Definition Language）是数据定义语言的缩写，简单来说，就是对<strong>数据库内部的对象</strong>进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul></li></ul><ol start="3"><li>执行速度不同<br><code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></li></ol><h1 id="9-数据库设计通常分为哪几步？"><a href="#9-数据库设计通常分为哪几步？" class="headerlink" title="9. 数据库设计通常分为哪几步？"></a>9. 数据库设计通常分为哪几步？</h1><ol><li><strong>需求</strong>分析 : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构</strong>设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构</strong>设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构</strong>设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol><h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p><strong>字符集</strong> 就是一系列字符的集合。<br>常见的字符集有 <code>ASCII</code>、<code>GB2312</code>、<code>GBK</code>、<code>GB18030</code>、<code>BIG5</code>、<code>UTF-8</code>……。<br><code>ASCII</code>：128 个字符<br><code>GB2312</code>：6700 多个汉字<br><code>GBK</code>：20000 多个汉字<br><code>GB18030</code>：最全面的汉字字符集<br><code>BIG5</code>：繁体中文<br><code>utf8</code>： utf8编码只支持1-3个字节 。<br><code>utf8mb4</code>：<code>UTF-8</code> 的完整实现，存储 emoji 符号。</p><h1 id="MySQL知识点-amp-面试题总结"><a href="#MySQL知识点-amp-面试题总结" class="headerlink" title="MySQL知识点&amp;面试题总结"></a>MySQL知识点&amp;面试题总结</h1><h1 id="1-MySQL-基础"><a href="#1-MySQL-基础" class="headerlink" title="1. MySQL 基础"></a>1. MySQL 基础</h1><h2 id="1-关系型数据库介绍"><a href="#1-关系型数据库介绍" class="headerlink" title="1. 关系型数据库介绍"></a>1. 关系型数据库介绍</h2><p>关系型数据库就是一种<strong>建立在关系模型的基础上的数据库</strong>。<br><strong>关系模型</strong>表明了数据库中所存储的<strong>数据之间的联系</strong>（一对一、一对多、多对多）。<br>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。<br><img src="https://img-blog.csdnimg.cn/82aba4314d0f437f8f1a99d79f22e358.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="DB"><br>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。<br>（MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite））</p><h1 id="2-MySQL-介绍"><a href="#2-MySQL-介绍" class="headerlink" title="2. MySQL 介绍"></a>2. MySQL 介绍</h1><p>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h1 id="1-存储引擎相关的命令"><a href="#1-存储引擎相关的命令" class="headerlink" title="1. 存储引擎相关的命令"></a>1. 存储引擎相关的命令</h1><p><strong>查看 MySQL 提供的所有存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure><p><code>MySQL</code> 当前默认的存储引擎是 <code>InnoDB</code>，并且在 5.7 版本所有的存储引擎中只有 <code>InnoDB</code> 是事务性存储引擎，也就是说只有 <code>InnoDB</code> 支持事务。<br><strong>查看 MySQL 当前默认的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%storage_engine%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>查看表的存储引擎</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> status <span class="keyword">like</span> &quot;table_name&quot; ;</span><br></pre></td></tr></table></figure><h1 id="2-MyISAM-和-InnoDB-的区别"><a href="#2-MyISAM-和-InnoDB-的区别" class="headerlink" title="2. MyISAM 和 InnoDB 的区别"></a>2. MyISAM 和 InnoDB 的区别</h1><ol><li>是否支持<strong>行级锁</strong></li></ol><ul><li><code>MyISAM</code> 只有<strong>表级锁</strong>(table-level locking)（一锁就是锁住了整张表）</li><li><code>InnoDB</code> 支持<strong>行级锁</strong>(row-level locking)和<strong>表级锁</strong>，默认为行级锁。</li></ul><ol start="2"><li>是否支持<strong>事务</strong><br><code>MyISAM</code> 不提供事务支持。<br><code>InnoDB</code> 提供事务支持，具有<strong>提交</strong>(commit)和<strong>回滚</strong>(rollback)事务的能力。</li><li>是否支持<strong>外键</strong><br><code>MyISAM</code> 不支持，而 &#96;InnoDB 支持。</li><li>是否支持数据库<strong>异常崩溃后的安全恢复</strong><br><code>MyISAM</code> 不支持，而 <code>InnoDB</code> 支持（依赖于 <code>redo log</code>）。</li></ol><h1 id="3-锁机制与-InnoDB-锁算法"><a href="#3-锁机制与-InnoDB-锁算法" class="headerlink" title="3. 锁机制与 InnoDB 锁算法"></a>3. 锁机制与 InnoDB 锁算法</h1><ul><li><strong>表级锁</strong>：资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，<strong>并发度最低</strong>，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁</strong>： 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。<br>InnoDB 存储引擎的锁的算法有三种：</li><li><code>Record lock</code>：<strong>记录锁</strong>，单个行记录上的锁</li><li><code>Gap lock</code>：<strong>间隙锁</strong>，锁定一个范围，不包括记录本身</li><li><code>Next-key lock</code>：<code>record+gap</code> <strong>临键锁</strong>，锁定一个范围，包含记录本身<h1 id="4-查询缓存"><a href="#4-查询缓存" class="headerlink" title="4. 查询缓存"></a>4. 查询缓存</h1>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除）。<br>my.cnf 加入以下配置，重启 MySQL 开启查询缓存<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type<span class="operator">=</span><span class="number">1</span></span><br><span class="line">query_cache_size<span class="operator">=</span><span class="number">600000</span></span><br></pre></td></tr></table></figure>MySQL 执行以下命令也可以开启查询缓存<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  query_cache_type<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  query_cache_size<span class="operator">=</span><span class="number">600000</span>;</span><br></pre></td></tr></table></figure>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_no_cache <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> usr;</span><br></pre></td></tr></table></figure></li></ul><p><strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。</strong><br><strong>查询缓存不命中的三种情况：</strong><br>（1）因此任何两个查询在任何字符上的不同都会导致缓存不命中。<br>（2）如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、<code>MySQL</code> 库中的系统表，其查询结果也不会被缓存。<br>（3）缓存建立之后，<code>MySQL</code> 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 </p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>事务是逻辑上的一组操作，<strong>要么都执行，要么都不执行</strong>。</p><h2 id="1-何为数据库事务？"><a href="#1-何为数据库事务？" class="headerlink" title="1. 何为数据库事务？"></a>1. 何为数据库事务？</h2><p>数据库事务可以<strong>保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体</strong>。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启一个事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"># 多条 <span class="keyword">SQL</span> 语句</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/c120bf0b528b42e6a7260982ec051026.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_11,color_FFFFFF,t_70,g_se,x_16" alt="sql"></p><h1 id="2-何为-ACID-特性呢？"><a href="#2-何为-ACID-特性呢？" class="headerlink" title="2. 何为 ACID 特性呢？"></a>2. 何为 ACID 特性呢？</h1><p>关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有 ACID 特性：</p><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；<strong>（<code>undo log</code> (回滚日志) ）</strong></li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；<strong>（锁机制、<code>MVCC</code> ）</strong></li><li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。<strong>（ <code>redo log</code> (重做日志) ）</strong><h1 id="3-数据事务的实现原理呢？（以-MySQL-的-InnoDB-引擎为例）"><a href="#3-数据事务的实现原理呢？（以-MySQL-的-InnoDB-引擎为例）" class="headerlink" title="3. 数据事务的实现原理呢？（以 MySQL 的 InnoDB 引擎为例）"></a>3. 数据事务的实现原理呢？（以 MySQL 的 InnoDB 引擎为例）</h1><code>MySQL InnoDB</code> 引擎使用 <code>redo log</code> (重做日志) 保证事务的持久性，使用 <code>undo log</code> (回滚日志) 来保证事务的原子性。<br><code>MySQL InnoDB</code> 引擎通过 锁机制、<code>MVCC</code> 等手段来保证事务的隔离性（ 默认支持的隔离级别是 <code>REPEATABLE-READ</code> ）。<h1 id="4-并发事务带来哪些问题？"><a href="#4-并发事务带来哪些问题？" class="headerlink" title="4. 并发事务带来哪些问题？"></a>4. 并发事务带来哪些问题？</h1></li><li><strong>脏读（Dirty read）</strong>：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。</li><li><strong>丢失修改（Lost to modify）</strong>：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。</li><li><strong>不可重复读（Unrepeatable read）</strong>：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。</li><li><strong>幻读（Phantom read）</strong>：它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。<br><strong>不可重复读和幻读区别：</strong><br>不可重复读的重点是修改比如多次读取一条记录发现其中<strong>某些列的值被修改</strong>，幻读的重点在于<strong>新增或者删除</strong>比如多次查询同一条查询语句（DQL）时，记录发现记录增多或减少了。<h1 id="5-事务隔离级别有哪些？"><a href="#5-事务隔离级别有哪些？" class="headerlink" title="5. 事务隔离级别有哪些？"></a>5. 事务隔离级别有哪些？</h1></li></ol><ul><li>**READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>**READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>**REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>**SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">READ-UNCOMMITTED</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">READ-COMMITTED</td><td align="center">×</td><td align="center">✓</td><td align="center">✓</td></tr><tr><td align="center">READ-UNCOMMITTED</td><td align="center">×</td><td align="center">×</td><td align="center">✓</td></tr><tr><td align="center">SERIALIZABLE</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h1 id="6-MySQL-的默认隔离级别是什么？"><a href="#6-MySQL-的默认隔离级别是什么？" class="headerlink" title="6. MySQL 的默认隔离级别是什么？"></a>6. MySQL 的默认隔离级别是什么？</h1><p><code>MySQL InnoDB</code> 存储引擎的默认支持的隔离级别是 <strong><code>REPEATABLE-READ</code>（可重读）</strong>。<br>并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁读使用到的机制就是 <code>Next-Key Locks</code> （<code>record+gap 临键锁</code>，锁定一个范围，包含记录本身）。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <code>READ-COMMITTED</code> (读取提交内容) ，但是你要知道的是 InnoDB 存储引擎默认使用 <code>REPEATABLE-READ</code>（可重读） 并不会有任何性能损失。</p><h1 id="Redis-知识点-amp-面试题总结"><a href="#Redis-知识点-amp-面试题总结" class="headerlink" title="Redis 知识点&amp;面试题总结"></a>Redis 知识点&amp;面试题总结</h1><h1 id="1-简单介绍一下-Redis"><a href="#1-简单介绍一下-Redis" class="headerlink" title="1. 简单介绍一下 Redis"></a>1. 简单介绍一下 Redis</h1><p> C 语言开发的数据库；存在内存中的 ，也就是它是内存数据库，所以读写速度非常快。<br> Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</p><h1 id="2-分布式缓存常见的技术选型方案有哪些？"><a href="#2-分布式缓存常见的技术选型方案有哪些？" class="headerlink" title="2. 分布式缓存常见的技术选型方案有哪些？"></a>2. 分布式缓存常见的技术选型方案有哪些？</h1><p><code>Memcached</code> 和 <code>Redis</code>。<br>分布式缓存主要解决的是<strong>单机缓存的容量受服务器限制并且无法保存通用信息的问题</strong>。因为，本地缓存只在当前服务里有效，比如如果你部署了两个相同的服务，他们两者之间的缓存数据是无法共同的。</p><h1 id="3-Redis-和-Memcached-的区别和共同点"><a href="#3-Redis-和-Memcached-的区别和共同点" class="headerlink" title="3. Redis 和 Memcached 的区别和共同点"></a>3. Redis 和 Memcached 的区别和共同点</h1><p><strong>共同点：</strong></p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别：</strong></p><ol><li><code>Redis</code> 支持更丰富的数据类型（支持更复杂的应用场景）。<code>Redis</code> 不仅仅支持简单的 <code>k/v</code> 类型的数据，同时还提供 <code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code> 等数据结构的存储。<code>Memcached</code> 只支持最简单的 <code>k/v</code> 数据类型。</li><li><code>Redis</code> 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 <code>Memcached</code> 把数据全部存在内存之中。</li><li><code>Redis</code> 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。</li><li><code>Redis</code> 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，<code>Memcached</code> 在服务器内存使用完之后，就会直接报异常。</li><li><code>Memcached</code> 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 <code>Redis</code> 目前是原生支持 <code>cluster</code> 模式的。</li><li><code>Memcached</code> 是多线程，非阻塞 <code>IO</code> 复用的网络模型；Redis 使用单线程的多路 <code>IO</code> 复用模型。 （<code>Redis 6.0</code> 引入了多线程 IO ）</li><li><code>Redis</code> 支持发布订阅模型、<code>Lua</code> 脚本、事务等功能，而 <code>Memcached</code> 不支持。并且，<code>Redis</code> 支持更多的编程语言。</li><li><code>Memcached</code> 过期数据的删除策略只用了惰性删除，而 <code>Redis</code> 同时使用了惰性删除与定期删除。<h1 id="2-缓存数据的处理流程是怎样的？"><a href="#2-缓存数据的处理流程是怎样的？" class="headerlink" title="2. 缓存数据的处理流程是怎样的？"></a>2. 缓存数据的处理流程是怎样的？</h1><img src="https://img-blog.csdnimg.cn/34510fc5f10d405c8d187adde2bcc536.png" alt="在这里插入图片描述"></li><li>如果用户请求的数据在缓存中就直接返回。</li><li>缓存中不存在的话就看数据库中是否存在。</li><li>数据库中存在的话就更新缓存中的数据。</li><li>数据库中不存在的话就返回空数据。<h1 id="3-为什么要用-Redis-x2F-为什么要用缓存？"><a href="#3-为什么要用-Redis-x2F-为什么要用缓存？" class="headerlink" title="3. 为什么要用 Redis&#x2F;为什么要用缓存？"></a>3. 为什么要用 Redis&#x2F;为什么要用缓存？</h1>简单，来说使用缓存主要是为了<strong>提升用户体验以及应对更多的用户</strong>。<br><strong>高性能</strong>：保证用户下一次再访问这些数据的时候就可以<strong>直接从缓存中获取</strong>了。操作缓存就是直接操作内存，所以速度相当快。<br>不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！<br><strong>高并发：</strong><br><strong>直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的</strong>，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。<br>（一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。）<br>（QPS（Query Per Second）：服务器每秒可以执行的查询次数。）<h1 id="4-Redis-除了做缓存，还能做什么？"><a href="#4-Redis-除了做缓存，还能做什么？" class="headerlink" title="4. Redis 除了做缓存，还能做什么？"></a>4. Redis 除了做缓存，还能做什么？</h1></li></ol><ul><li>分布式锁</li><li>限流：<code>Redis</code> 和 <code>lLua</code> 脚本</li><li>消息队列：<code>Redis</code> 自带的 <code>list</code> 数据结构可以作为一个简单的队列使用。</li><li>复杂业务场景</li></ul><h1 id="5-Redis-没有使用多线程？为什么不使用多线程？"><a href="#5-Redis-没有使用多线程？为什么不使用多线程？" class="headerlink" title="5. Redis 没有使用多线程？为什么不使用多线程？"></a>5. Redis 没有使用多线程？为什么不使用多线程？</h1><p><code>Redis 4.0</code> 增加的多线程主要是<strong>针对一些大键值对的删除操作的命令</strong>，使用这些命令就会使用主处理之外的其他线程来“异步处理”。</p><ol><li><code>Redis6.0</code> 之前 为什么不使用多线程？<ol><li>单线程编程容易并且更容易维护；</li><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ol></li><li>Redis6.0 之后为何引入了多线程？<br> 主要是为了提高网络 IO 读写性能。（性能瓶颈（Redis 的瓶颈主要受限于内存和网络））<br> 虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</li></ol><h1 id="6-Redis-给缓存数据设置过期时间有啥用？"><a href="#6-Redis-给缓存数据设置过期时间有啥用？" class="headerlink" title="6. Redis 给缓存数据设置过期时间有啥用？"></a>6. Redis 给缓存数据设置过期时间有啥用？</h1><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 <code>Out of memory</code>。<br>（其他作用如验证码&#x2F;登录信息等）</p><h1 id="7-Redis-是如何判断数据是否过期的呢？"><a href="#7-Redis-是如何判断数据是否过期的呢？" class="headerlink" title="7. Redis 是如何判断数据是否过期的呢？"></a>7. Redis 是如何判断数据是否过期的呢？</h1><p><code>Redis</code> 通过一个叫做<strong>过期字典</strong>（可以看作是 <code>hash</code> 表）来保存数据过期的时间。<br>过期字典的键指向 <code>Redis</code> 数据库中的某个 <code>key</code>(键)，过期字典的值是一个 <code>long long</code> 类型的整数，这个整数保存了 <code>key</code> 所指向的数据库键的过期时间（毫秒精度的 <code>UNIX</code> 时间戳）。</p><h1 id="8-过期的数据的删除策略了解么？"><a href="#8-过期的数据的删除策略了解么？" class="headerlink" title="8. 过期的数据的删除策略了解么？"></a>8. 过期的数据的删除策略了解么？</h1><p>常用的过期数据的删除策略就两个</p><ol><li><p><strong>惰性删除</strong>：只会在取出 <code>key</code> 的时候才对数据进行过期检查。这样对 <code>CPU</code> 最友好，但是可能会造成太多过期 <code>key</code> 没有被删除。<strong>（对CPU好）</strong></p></li><li><p><strong>定期删除</strong>：每隔一段时间抽取一批 <code>key</code> 执行删除过期 <code>key</code> 操作。并且，<code>Redis</code> 底层会通过限制删除操作执行的时长和频率来减少删除操作对 <code>CPU</code> 时间的影响。<strong>（对内存好）</strong><br><code>Redis</code> 采用的是 <strong>定期删除+惰性删除</strong>。<code>Redis</code> 内存淘汰机制。</p><h1 id="9-Redis-内存淘汰机制了解么？"><a href="#9-Redis-内存淘汰机制了解么？" class="headerlink" title="9. Redis 内存淘汰机制了解么？"></a>9. Redis 内存淘汰机制了解么？</h1><p><code>Redis</code> 提供 6 种数据淘汰策略：</p></li><li><p><code>volatile-lru</code>（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p></li><li><p><code>volatile-ttl</code>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p></li><li><p><code>volatile-random</code>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p></li><li><p><code>allkeys-lru</code>（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p></li><li><p><code>allkeys-random</code>：从数据集（server.db[i].dict）中任意选择数据淘汰</p></li><li><p><code>no-eviction</code>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！<br>4.0 版本后增加以下两种：</p></li><li><p><code>volatile-lfu</code>（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选<strong>最不经常使用</strong>的数据淘汰</p></li><li><p><code>allkeys-lfu</code>（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，<strong>移除最不经常使用的 <code>key</code></strong></p><h1 id="10-Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#10-Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="10. Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)"></a>10. Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</h1></li><li><p><strong>快照（snapshotting）持久化（RDB）</strong>（默认）<br><code>Redis</code> 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。<br>Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p></li><li><p><strong>AOF（append-only file）持久化</strong><br>与快照持久化相比，<code>AOF</code> 持久化的<strong>实时性更好</strong>，因此已成为主流的持久化方案。<br>开启 <code>AOF</code> 持久化后每执行一条会更改 <code>Redis</code> 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf </code>中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 <code>AOF</code> 文件。<br>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 <code>Redis</code> 每秒同步一次 <code>AOF</code> 文件，<code>Redis</code> 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。</p></li></ol><h1 id="11-Redis-bigkey"><a href="#11-Redis-bigkey" class="headerlink" title="11. Redis bigkey"></a>11. Redis bigkey</h1><p><code>bigkey</code>：简单来说，如果一个 <code>key</code> 对应的 <code>value</code> 所占用的内存比较大。会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。<br>如何发现 bigkey？<br>1、使用 Redis 自带的 –bigkeys 参数来查找。<br>2、分析 RDB 文件。前提是RDB持久化，现成代码套用。</p><h1 id="12-Redis-事务"><a href="#12-Redis-事务" class="headerlink" title="12. Redis 事务"></a>12. Redis 事务</h1><p><code>Redis</code> 可以通过 <code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code> 等命令来实现事务(transaction)功能。</p><ul><li><code>MULTI</code> ：开始<code>EXEC</code>：执行<code>DISCARD</code>：取消<code>WATCH</code>：监听指定的键<br>（被 <code>WATCH</code> 命令监视的键被修改的话，整个事务都不会执行，直接返回失败。）</li></ul><p>使用 <code>MULTI</code> 命令后可以输入多个命令。<code>Redis</code> 不会立即执行这些命令，而是将它们放到队列，当调用了 <code>EXEC</code> 命令将执行所有命令。<br>这个过程是这样的：</p><ol><li>开始事务（<code>MULTI</code>）。</li><li>命令入队(批量操作 <code>Redis</code> 的命令，先进先出（FIFO）的顺序执行)。</li><li>执行事务(<code>EXEC</code>)。</li></ol><p><code>Redis</code> 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。ACID</p><h1 id="13-Redis-可以做消息队列么？"><a href="#13-Redis-可以做消息队列么？" class="headerlink" title="13. Redis 可以做消息队列么？"></a>13. Redis 可以做消息队列么？</h1><p><code>Redis 5.0</code> 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，Stream 支持：</p><ul><li>发布 &#x2F; 订阅模式</li><li>按照消费者组进行消费</li><li>消息持久化（ RDB 和 AOF）<br>和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。<br>选择市面上比较成熟的一些消息队列比如 <code>RocketMQ</code>、<code>Kafka</code>。<h1 id="14-缓存穿透"><a href="#14-缓存穿透" class="headerlink" title="14. 缓存穿透"></a>14. 缓存穿透</h1>大量请求的 <code>key</code> 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。<br><strong>有哪些解决办法？</strong><br>1）<strong>缓存无效 <code>key</code></strong><br>如果缓存和数据库都查不到某个 <code>key</code> 的数据就写一个到 <code>Redis</code> 中去并设置过期时间<br>2）<strong>布隆过滤器</strong><br>把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。<br><strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></li></ul><p><strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><h1 id="15-缓存雪崩"><a href="#15-缓存雪崩" class="headerlink" title="15. 缓存雪崩"></a>15. 缓存雪崩</h1><p><strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong><br>这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。<br>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong>（如秒杀活动）</p><ol><li><p>针对 <code>Redis</code> <strong>服务不可用</strong>的情况：</p><ol><li>采用 <code>Redis</code> 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol></li><li><p>针对<strong>热点缓存失效</strong>的情况：</p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol></li></ol><h1 id="16-如何保证缓存和数据库数据的一致性？"><a href="#16-如何保证缓存和数据库数据的一致性？" class="headerlink" title="16. 如何保证缓存和数据库数据的一致性？"></a>16. 如何保证缓存和数据库数据的一致性？</h1><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短</strong>（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加 <code>cache</code> 更新重试机制</strong>（常用）： 如果 <code>cache</code> 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 <code>key</code> 存入队列中，等缓存服务可用之后，再将缓存中对应的 <code>key</code> 删除即可。</li></ol><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/0fa20b02a1a7492d975f4ffeb1f8f6ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础知识整理</title>
      <link href="/2022/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="OSI-和-TCP-x2F-IP-网络分层模型详解（基础）"><a href="#OSI-和-TCP-x2F-IP-网络分层模型详解（基础）" class="headerlink" title="OSI 和 TCP&#x2F;IP 网络分层模型详解（基础）"></a>OSI 和 TCP&#x2F;IP 网络分层模型详解（基础）</h1><h2 id="1-OSI-七层模型"><a href="#1-OSI-七层模型" class="headerlink" title="1. OSI 七层模型"></a>1. OSI 七层模型</h2><p><img src="https://img-blog.csdnimg.cn/036338b551204cd6a254c1b364393609.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="OSI 七层模型"><br><img src="https://img-blog.csdnimg.cn/e3c9eca741cc4eefb2b7100011b69f4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="TCP/IP"></p><h2 id="2-TCP-x2F-IP-四层模型"><a href="#2-TCP-x2F-IP-四层模型" class="headerlink" title="2. TCP&#x2F;IP 四层模型"></a>2. TCP&#x2F;IP 四层模型</h2><p><code>TCP/IP</code> 模型看作是 <code>OSI</code> 七层模型的精简版本，由以下 4 层组成：<br><img src="https://img-blog.csdnimg.cn/a6c2e660cd024664a80d45c573b9655b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="TCP/IP四层模型"></p><h2 id="2-1-应用层（Application-layer）"><a href="#2-1-应用层（Application-layer）" class="headerlink" title="2.1 应用层（Application layer）"></a>2.1 应用层（Application layer）</h2><p>应用层位于传输层之上，主要<strong>提供两个终端设备上的应用程序之间信息交换的服务</strong>，它定义了信息交换的格式，消息会交给下一层传输层来传输。 我们把应用层交互的数据单元称为<strong>报文</strong>。<br><img src="https://img-blog.csdnimg.cn/72df7fd6afbe4d4780dbc3fc27415be0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_11,color_FFFFFF,t_70,g_se,x_16" alt="应用层"></p><h2 id="2-2-传输层（Transport-layer）"><a href="#2-2-传输层（Transport-layer）" class="headerlink" title="2.2 传输层（Transport layer）"></a>2.2 传输层（Transport layer）</h2><p><strong>负责向两台终端设备进程之间的通信提供通用的数据传输服务</strong>。<br>应用进程利用该服务<strong>传送应用层报文</strong>。<br>“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。<br>运输层主要使用以下两种协议：</p><ul><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠</strong>的数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，<strong>尽最大努力</strong>的数据传输服务（不保证数据传输的可靠性）。<br> <img src="https://img-blog.csdnimg.cn/83296d947f7346358a51a5ba5f612427.png" alt="在这里插入图片描述"></li></ul><h2 id="2-3-网络层（Network-layer）"><a href="#2-3-网络层（Network-layer）" class="headerlink" title="2.3 网络层（Network layer）"></a>2.3 网络层（Network layer）</h2><p>① <strong>负责为分组交换网上的不同主机提供通信服务。</strong><br>② 网络层的还有一个任务就是<strong>选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机</strong>。<br>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。<br>在 <code>TCP/IP</code> 体系结构中，由于网络层使用 <code>IP</code> 协议，因此分组也叫 <strong><code>IP</code> 数据报</strong>，简称<strong>数据报</strong>。<br>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层或IP 层</strong>。<br><img src="https://img-blog.csdnimg.cn/c489dacb4fef47edac45174255a6689d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_11,color_FFFFFF,t_70,g_se,x_16" alt="网络层"></p><h2 id="2-4-网络接口层（Network-interface-layer）（数据链路层和物理层）"><a href="#2-4-网络接口层（Network-interface-layer）（数据链路层和物理层）" class="headerlink" title="2.4 网络接口层（Network interface layer）（数据链路层和物理层）"></a>2.4 网络接口层（Network interface layer）（数据链路层和物理层）</h2><ol><li><strong>数据链路层</strong>的作用是：将网络层交下来的 <strong>IP 数据报组装成帧</strong>，在两个<strong>相邻节点间的链路上传送帧</strong>。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li><li><strong>物理层</strong>的作用是：实现<strong>相邻</strong>计算机<strong>节点之间比特流的透明传送</strong>，尽可能屏蔽掉具体传输介质和物理设备的差异。<h2 id="3-为什么网络要分层？"><a href="#3-为什么网络要分层？" class="headerlink" title="3. 为什么网络要分层？"></a>3. 为什么网络要分层？</h2></li><li><strong>各层之间相互独立</strong>：可不关心其它层。</li><li><strong>提高了整体灵活性</strong>：高内聚、低耦合。</li><li><strong>大问题化小</strong>：分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。<h1 id="HTTP-vs-HTTPS（应用层）"><a href="#HTTP-vs-HTTPS（应用层）" class="headerlink" title="HTTP vs HTTPS（应用层）"></a>HTTP vs HTTPS（应用层）</h1><h1 id="HTTP-协议（扩展性强、速度快、跨平台支持性好）"><a href="#HTTP-协议（扩展性强、速度快、跨平台支持性好）" class="headerlink" title="HTTP 协议（扩展性强、速度快、跨平台支持性好）"></a>HTTP 协议（扩展性强、速度快、跨平台支持性好）</h1><h2 id="1-HTTP-协议介绍"><a href="#1-HTTP-协议介绍" class="headerlink" title="1. HTTP 协议介绍"></a>1. HTTP 协议介绍</h2>HTTP 协议，全称<strong>超文本传输协议</strong>（Hypertext Transfer Protocol）。HTTP 协议就是用来<strong>规范超文本（网络上各种消息）的传输</strong>，规范浏览器和服务器端的行为的。<br>HTTP 是一个<strong>无状态（stateless）协议</strong>，也就是说<strong>服务器不维护任何有关客户端过去所发请求的消息</strong>。这其实是一种懒政，<strong>有状态协议会更加复杂</strong>，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。<h2 id="2-HTTP-协议通信过程"><a href="#2-HTTP-协议通信过程" class="headerlink" title="2. HTTP 协议通信过程"></a>2. HTTP 协议通信过程</h2><code>HTTP</code> 是应用层协议，它以 <code>TCP</code>（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</li><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 <code>TCP</code> 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 <code>TCP</code> 连接。</li><li>浏览器（<code>HTTP</code> 客户端）与 <code>Web</code> 服务器（<code>HTTP</code> 服务器）交换 <code>HTTP</code> 消息。</li><li>关闭 <code>TCP</code> 连接。<h1 id="HTTPS-协议（保密性好、信任度高。）"><a href="#HTTPS-协议（保密性好、信任度高。）" class="headerlink" title="HTTPS 协议（保密性好、信任度高。）"></a>HTTPS 协议（保密性好、信任度高。）</h1><h2 id="1-HTTPS-协议介绍"><a href="#1-HTTPS-协议介绍" class="headerlink" title="1. HTTPS 协议介绍"></a>1. HTTPS 协议介绍</h2><code>HTTPS </code>协议（<code>Hyper Text Transfer Protocol Secure</code>），是 <code>HTTP</code> 的加强安全版本。<code>HTTPS</code> 是基于 <code>HTTP</code> 的，也是用 <code>TCP</code> 作为底层协议，并额外使用 <code>SSL/TLS</code> 协议用作加密和安全认证。默认端口号是 443<br><code>HTTPS</code> 协议中，<code>SSL</code> 通道通常使用<strong>基于密钥的加密算法</strong>，密钥长度通常是 40 比特或 128 比特。<h2 id="2-HTTPS-的核心—SSL-x2F-TLS协议"><a href="#2-HTTPS-的核心—SSL-x2F-TLS协议" class="headerlink" title="2. HTTPS 的核心—SSL&#x2F;TLS协议"></a>2. HTTPS 的核心—SSL&#x2F;TLS协议</h2>结合了 SSL&#x2F;TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。<h3 id="1-SSL-和-TLS-的区别？"><a href="#1-SSL-和-TLS-的区别？" class="headerlink" title="1. SSL 和 TLS 的区别？"></a>1. SSL 和 TLS 的区别？</h3>没有太大的区别。<code>SSL</code> 指安全套接字协议（Secure Sockets Layer），始发1996年，1999 年SSL 3.0 进一步升级，新版本被命名为 <code>TLS</code> 1.0。通常把 <code>HTTPS</code> 中的核心加密协议混成为 <code>SSL/TLS</code>。<h3 id="2-SSL-x2F-TLS-的工作原理"><a href="#2-SSL-x2F-TLS-的工作原理" class="headerlink" title="2. SSL&#x2F;TLS 的工作原理"></a>2. SSL&#x2F;TLS 的工作原理</h3>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——<strong>一个公钥(加密者)，一个私钥(解密者)<strong>。在通信时，私钥仅由</strong>解密者</strong>保存，公钥由任何一个想与解密者通信的发送者（<strong>加密者</strong>）所知。<br><strong>非对称加密</strong>：公钥和私钥需要采用一种复杂的数学机制生成。公私钥对的生成算法依赖于<strong>单向陷门函数</strong>。（计算的代价较高，效率太低）<br><strong>对称加密</strong>：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。<br><strong>使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听</strong>。这样通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。<br>当客户端（浏览器）向服务器发送 <code>HTTPS</code> 请求时，一定要先<strong>获取目标服务器的证书</strong>，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>端口号 ：HTTP 默认是 80，HTTPS 默认是 443。</li><li>URL 前缀 ：HTTP 的 URL 前缀是 http:&#x2F;&#x2F;，HTTPS 的 URL 前缀是 https:&#x2F;&#x2F;。</li><li>安全性和资源消耗 ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ul><h1 id="HTTP-1-0-vs-HTTP-1-1（应用层）"><a href="#HTTP-1-0-vs-HTTP-1-1（应用层）" class="headerlink" title="HTTP 1.0 vs HTTP 1.1（应用层）"></a>HTTP 1.0 vs HTTP 1.1（应用层）</h1><h2 id="1-响应状态码"><a href="#1-响应状态码" class="headerlink" title="1. 响应状态码"></a>1. 响应状态码</h2><p><code>HTTP/1.0</code> 仅定义了16种状态码。<code>HTTP/1.1</code> 中大量状态码，错误响应状态码就新增24种。<br><code>100 (Continue)</code>——在请求大资源前的预热请求，<br><code>206 (Partial Content)</code>——范围请求的标识码，<br><code>409 (Conflict)</code>——请求与当前资源的规定冲突，<br><code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。<br><img src="https://img-blog.csdnimg.cn/4081708cc9d14f53bc94cf35d2e96683.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_16,color_FFFFFF,t_70,g_se,x_16" alt="状态码"></p><h2 id="2-缓存处理"><a href="#2-缓存处理" class="headerlink" title="2. 缓存处理"></a>2. 缓存处理</h2><p>缓存技术<strong>通过避免用户与源服务器的频繁交互</strong>，<strong>节约</strong>了大量的<strong>网络带宽</strong>，<strong>降低</strong>了用户接收信息的<strong>延迟</strong>。</p><ol><li>HTTP&#x2F;1.0<br>提供的缓存机制非常简单。<br><code>Expires</code> 标签：标志（时间）一个响应体，在 <code>Expires</code> 标志时间内的请求，都会获得该响应体缓存。<br><code>Last-Modified</code> ：标记了被请求资源在服务器端的最后一次修改。<br><code>If-Modified-Since</code>：标志一个时间，意为客户端向服务器进行问询是否修改。</li></ol><ul><li>如果服务器接收到了请求头，并判断 <code>If-Modified-Since</code> 时间后，资源确实没有修改过，则返回给客户端一个<code> 304 not modified</code> 响应头，表示”缓冲可用，你从浏览器里拿吧！”。</li><li>如果服务器判断 <code>If-Modified-Since</code> 时间后，资源被修改过，则返回给客户端一个 <code>200 OK</code> 的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</li></ul><ol start="2"><li>HTTP&#x2F;1.1<br>缓存机制在 <code>HTTP/1.0</code> 的基础上，大大增加了灵活性和扩展性。基本工作原理和 <code>HTTP/1.0</code> 保持不变，而是增加了更多细致的特性。其中，<strong>请求头中最常见的特性就是 <code>Cache-Control</code></strong> 。</li></ol><h2 id="3-连接方式"><a href="#3-连接方式" class="headerlink" title="3. 连接方式"></a>3. 连接方式</h2><p><strong><code>HTTP/1.0</code> 默认使用短连接</strong>，也就是说，客户端和服务器每进行一次 <code>HTTP</code> 操作，就建立一次连接，任务结束就中断连接。<br>当客户端浏览器访问的某个 <code>HTML</code> 或其他类型的 <code>Web</code> 页中包含有其他的 <code>Web</code> 资源，<strong>每遇到</strong>这样一个 <code>Web</code> 资源，浏览器就会重新<strong>建立一个TCP连接</strong>，这样就会导致有大量的<strong>“握手报文”和“挥手报文”</strong>占用了带宽。</p><p><strong>HTTP&#x2F;1.1 优化为默认长连接模式</strong>。采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于<strong>传输 HTTP 数据的 TCP 连接不会关闭</strong>，客户端再次访问这个服务器时，会<strong>继续使用这一条已经建立的连接</strong>。</p><p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持<strong>超时时间</strong>的时间。在超时时间之内没有新的请求达到，<strong>TCP 连接才会被关闭</strong>。<br>（有必要说明的是，<code>HTTP/1.0</code><strong>仍提供</strong>了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 <code>HTTP/1.1</code> 中，如果不希望使用长连接选项，也可以在请求头中加入 <code>Connection: close</code> ，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。）<br>    * <strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。<br>    * 实现长连接需要客户端和服务端都支持长连接。</strong></p><h2 id="4-Host头处理"><a href="#4-Host头处理" class="headerlink" title="4. Host头处理"></a>4. Host头处理</h2><p><strong>域名系统</strong>（DNS）允许多个主机名绑定到同一个<code>IP</code>地址上，但是<code>HTTP/1.0</code>并没有考虑这个问题，假设我们有一个资源URL是 <code>http://example1.org/home.html</code> ，<code>HTTP/1.0</code>的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p><p>因此，<code>HTTP/1.1</code>在请求头中加入了 <code>Host</code> 字段。加入 <code>Host</code> 字段的报文头部将会是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /home.html HTTP/1.1</span><br><span class="line">Host: example1.org</span><br></pre></td></tr></table></figure><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p><h2 id="5-带宽优化"><a href="#5-带宽优化" class="headerlink" title="5. 带宽优化"></a>5. 带宽优化</h2><h3 id="1-范围请求"><a href="#1-范围请求" class="headerlink" title="1. 范围请求"></a>1. 范围请求</h3><p><code>HTTP/1.1</code> 引入了<strong>范围请求</strong>（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，<code>HTTP/1.1</code> 可以在请求中加入 <code>Range</code> 头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略 <code>Range</code> 头部，也可以返回若干 <code>Range</code> 响应。<br>如果一个响应包含部分数据的话，那么将带有 <code>206 (Partial Content)</code> 状态码。该状态码的意义在于避免了 <code>HTTP/1.0</code> 代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。<br>在范围响应中，<code>Content-Range</code> 头部标志指示出了该<strong>数据块的偏移量和数据块的长度</strong>。</p><h3 id="2-状态码100"><a href="#2-状态码100" class="headerlink" title="2. 状态码100"></a>2. 状态码100</h3><p>使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应<br><img src="https://img-blog.csdnimg.cn/832ba4d709a14bd6ad4a2aeeec525c73.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_9,color_FFFFFF,t_70,g_se,x_16" alt="状态码100"><br>然而在 <code>HTTP/1.0</code> 中，并没有 <code>100</code> (Continue)状态码，要想触发这一机制，可以发送一个 <code>Expect</code> 头部，其中包含一个 <code>100-continue</code> 的值。</p><h3 id="3-压缩"><a href="#3-压缩" class="headerlink" title="3. 压缩"></a>3. 压缩</h3><p>许多格式的数据在传输时都会做预压缩处理。<strong>数据的压缩可以大幅优化带宽的利用</strong>。然而，<code>HTTP/1.0</code> 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。<br><code>HTTP/1.1</code> 则对<strong>内容编码</strong>（content-codings，端到端）和<strong>传输编码</strong>（transfer-codings，逐跳）做了区分。<br><code>HTTP/1.0</code> 包含了 <code>Content-Encoding</code> 头部，对消息进行<strong>端到端编码</strong>。<code>HTTP/1.1</code> 加入了<code>Transfer-Encoding</code> 头部，可以对消息进行<strong>逐跳传输编码</strong>。<code>HTTP/1.1</code> 还加入了<code>Accept-Encoding</code> 头部，是客户端用来<strong>指示他能处理什么样的内容编码</strong>。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP&#x2F;1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存处理</strong> : 在 <code>HTTP1.0</code> 中主要使用 <code>header</code> 里的 <code>If-Modified-Since,Expires</code> 来做为缓存判断的标准，<code>HTTP1.1</code> 则引入了更多的缓存控制策略例如 <code>Entity tag</code>，<code>If-Unmodified-Since</code>, <code>If-Match</code>, <code>If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> : <code>HTTP1.0</code>  中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，<code>HTTP1.1</code> 则在请求头引入了 <code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host头处理</strong> : <code>HTTP/1.1</code> 在请求头中加入了 <code>Host</code> 字段。</li></ol><h1 id="计算机网络常见知识点-amp-面试题（补充）"><a href="#计算机网络常见知识点-amp-面试题（补充）" class="headerlink" title="计算机网络常见知识点&amp;面试题（补充）"></a>计算机网络常见知识点&amp;面试题（补充）</h1><h2 id="1-应用层有哪些常见的协议？"><a href="#1-应用层有哪些常见的协议？" class="headerlink" title="1. 应用层有哪些常见的协议？"></a>1. 应用层有哪些常见的协议？</h2><h3 id="1-HTTP：超文本传输协议"><a href="#1-HTTP：超文本传输协议" class="headerlink" title="1. HTTP：超文本传输协议"></a>1. HTTP：超文本传输协议</h3><p>Web 浏览器与 Web 服务器之间的通信而设计的。浏览器浏览网页就是通过 HTTP 请求进行加载。<br><img src="https://img-blog.csdnimg.cn/1d6c120fd762404c8529c85312fc1a81.png" alt="http"><br><code>HTTP</code> 协议是基于 TCP协议，发送 <code>HTTP</code> 请求之前首先要建立 <code>TCP</code> 连接也就是要经历 3 次握手。目前使用的 <code>HTTP</code> 协议大部分都是 <code>1.1</code> 。在 <code>1.1</code> 的协议里面，默认是开启了 <code>Keep-Alive</code> 的，这样的话建立的连接就可以在多次请求中被复用了。<br><code>HTTP</code> 协议是<strong>“无状态”的协议</strong>，它无法记录客户端用户的状态，一般我们都是通过 <strong><code>Session</code> 来记录客户端用户的状态</strong>。</p><h3 id="2-SMTP：简单邮件传输-发送-协议"><a href="#2-SMTP：简单邮件传输-发送-协议" class="headerlink" title="2. SMTP：简单邮件传输(发送)协议"></a>2. SMTP：简单邮件传输(发送)协议</h3><p>基于 TCP 协议，用来发送电子邮件。</p><ol><li>电子邮件的发送过程？<br>比如我的邮箱是“<a href="mailto:&#100;&#97;&#98;&#97;&#x69;&#64;&#x63;&#x73;&#x7a;&#104;&#x69;&#110;&#x61;&#110;&#46;&#99;&#x6f;&#109;">&#100;&#97;&#98;&#97;&#x69;&#64;&#x63;&#x73;&#x7a;&#104;&#x69;&#110;&#x61;&#110;&#46;&#99;&#x6f;&#109;</a>”，我要向“<a href="mailto:&#x78;&#105;&#97;&#111;&#109;&#97;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#x78;&#105;&#97;&#111;&#109;&#97;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a>”发送邮件，整个过程可以简单分为下面几步：<br>1.1 通过 <code>SMTP</code> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。<br>1.2 163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。<br>1.3 qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:&#x78;&#105;&#x61;&#x6f;&#109;&#x61;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#105;&#x61;&#x6f;&#109;&#x61;&#x40;&#x71;&#x71;&#x2e;&#x63;&#111;&#x6d;</a>”的用户来收邮件，然后用户就通过 POP3&#x2F;IMAP 协议将邮件取出。</li><li>如何判断邮箱是真正存在的？<br>利用 <code>SMTP</code> 协议来检测：<br>2.1 查找邮箱域名对应的 SMTP 服务器地址<br>2.2 尝试与服务器建立连接<br>2.3 连接成功后尝试向需要验证的邮箱发送邮件<br>2.4 根据返回结果判定邮箱地址的真实性<h3 id="3-POP3-x2F-IMAP：邮件（接收）的协议"><a href="#3-POP3-x2F-IMAP：邮件（接收）的协议" class="headerlink" title="3. POP3&#x2F;IMAP：邮件（接收）的协议"></a>3. POP3&#x2F;IMAP：邮件（接收）的协议</h3><code>SMTP</code> 协议只负责邮件的发送，真正负责接收的协议是 <code>POP3/IMAP</code> 。（<code>IMAP</code> 协议更新，功能更多）<h3 id="4-FTP：文件传输协议"><a href="#4-FTP：文件传输协议" class="headerlink" title="4. FTP：文件传输协议"></a>4. FTP：文件传输协议</h3><strong>功能</strong>：提供文件传输服务，基于 TCP 实现可靠的传输。<br><strong>好处</strong>：可以屏蔽操作系统和文件存储方式。<br><strong>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点</strong>：就在于它在两台通信的主机之间使用了<strong>两条 TCP 连接</strong>（其它客户服务器应用程序一般只有一条 TCP 连接）：</li><li><strong>控制连接</strong>：用于传送控制信息（命令和响应）</li><li><strong>数据连接</strong>：用于数据传送；<br>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。<br><img src="https://img-blog.csdnimg.cn/33adb04091b0483a85409f1b001a185b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="FTP"><h3 id="5-Telnet：远程登陆协议"><a href="#5-Telnet：远程登陆协议" class="headerlink" title="5. Telnet：远程登陆协议"></a>5. Telnet：远程登陆协议</h3><code>Telnet</code> 协议 通过一个终端登陆到其他服务器，<strong>建立在可靠的传输协议 TCP 之上</strong>。<code>Telnet</code> 协议的最大缺点之一是<strong>所有数据（包括用户名和密码）均以明文形式发送</strong>，这有潜在的安全风险。这就是为什么如今很少使用<code>Telnet</code> 并被一种称为 <code>SSH</code> 的非常安全的协议所取代的主要原因。<br><code>Telnet</code> 和 <code>SSH</code> 之间的主要区别在于 <strong><code>SSH</code> 协议会对传输的数据进行加密保证数据安全性</strong>。<h2 id="6-TCP-三次握手和四次挥手-面试常客"><a href="#6-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="6. TCP 三次握手和四次挥手(面试常客)"></a>6. TCP 三次握手和四次挥手(面试常客)</h2><strong>为了准确无误地把数据送达目标处</strong>，TCP 协议采用了三次握手策略。<br><img src="https://img-blog.csdnimg.cn/a193d4bb3984469b8b1eed1b3a3d0320.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="三次握手"><br><img src="https://img-blog.csdnimg.cn/efc6645cba9645ea9b029a270b962774.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_13,color_FFFFFF,t_70,g_se,x_16" alt="三次握手"></li><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN&#x2F;ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端<br><strong>响应报文</strong>（SYN(synchronous建立联机) ACK(acknowledgement 确认)）</li></ol><h3 id="1-为什么要三次握手？"><a href="#1-为什么要三次握手？" class="headerlink" title="1. 为什么要三次握手？"></a>1. 为什么要三次握手？</h3><p><strong>建立可靠的通信信道</strong>，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<strong>双方确认自己与对方的发送与接收是正常的</strong>。</p><h3 id="2-第-2-次握手传回了-ACK，为什么还要传回-SYN？"><a href="#2-第-2-次握手传回了-ACK，为什么还要传回-SYN？" class="headerlink" title="2. 第 2 次握手传回了 ACK，为什么还要传回 SYN？"></a>2. 第 2 次握手传回了 ACK，为什么还要传回 SYN？</h3><p><strong><code>ACK</code>（确认信号）</strong> 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。<br>而回传 <strong><code>SYN</code>（建立联机信号）</strong> 则是为了建立并确认从服务端到客户端的通信。”</p><h3 id="3-为什么要四次挥手？"><a href="#3-为什么要四次挥手？" class="headerlink" title="3. 为什么要四次挥手？"></a>3. 为什么要四次挥手？</h3><p><img src="https://img-blog.csdnimg.cn/efb89c2763024a699ca9bccde5d3ce71.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_12,color_FFFFFF,t_70,g_se,x_16" alt="四次握手"><br><strong>断开一个 TCP 连接</strong>则需要“四次挥手”：</p><ol><li>客户端-发送一个 <code>FIN</code>，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 <code>FIN</code>，它发回一 个 <code>ACK</code>，确认序号为收到的序号加 1 。和 <code>SYN</code> 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个 <code>FIN</code> 给客户端</li><li>客户端-发回 <code>ACK</code> 报文确认，并将确认序号设置为收到序号加 1</li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 <code>TCP</code> 连接。<br>（举个例子：A 和 B 打电话，通话即将结束后，A 说“<strong>我没啥要说的了</strong>”，B 回答“<strong>我知道了</strong>”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“<strong>我说完了</strong>”，A 回答“<strong>知道了</strong>”，这样通话才算结束。）</p><h2 id="7-TCP-UDP-协议的区别"><a href="#7-TCP-UDP-协议的区别" class="headerlink" title="7. TCP, UDP 协议的区别"></a>7. TCP, UDP 协议的区别</h2><p><img src="https://img-blog.csdnimg.cn/76a660068c7c41c8a89ff812d6befa96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="TCP UDP协议区别"><br><code>UDP</code> 在传送数据之前不需要先建立连接，远地主机在收到 <code>UDP</code> 报文后，不需要给出任何确认。虽然 <code>UDP</code> 不提供可靠交付，但在某些情况下 <code>UDP</code> 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p><code>TCP</code> 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 <code>TCP</code> 不提供广播或多播服务。由于 <code>TCP</code> 要提供可靠的，面向连接的传输服务（<code>TCP</code> 的可靠体现在 <code>TCP</code> 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。<code>TCP</code> 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h2 id="8-TCP-协议如何保证可靠传输"><a href="#8-TCP-协议如何保证可靠传输" class="headerlink" title="8. TCP 协议如何保证可靠传输"></a>8. TCP 协议如何保证可靠传输</h2><ol><li>应用数据被<strong>分割成 TCP 认为最适合发送的数据块</strong>。</li><li>TCP 给发送的每一个包进行<strong>编号</strong>，接收方对数据包进行<strong>排序</strong>，把有序数据传送给应用层。</li><li><strong>校验和</strong>： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制</strong>： 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ 协议</strong>： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传</strong>： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<h3 id="1-ARQ-（自动重传请求）协议-Automatic-Repeat-reQuest，ARQ"><a href="#1-ARQ-（自动重传请求）协议-Automatic-Repeat-reQuest，ARQ" class="headerlink" title="1. ARQ （自动重传请求）协议(Automatic Repeat-reQuest，ARQ)"></a>1. ARQ （自动重传请求）协议(Automatic Repeat-reQuest，ARQ)</h3> OSI 模型中数据链路层和传输层的错误纠正协议之一。<br> 它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。<br> ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</li></ol><p><strong>停止等待 ARQ 协议</strong> ：为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。<br>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p>优点： 简单。缺点： 信道利用率低，等待时间长</p><ol><li>无差错情况。2) 出现差错情况（超时重传）。3) 确认丢失和确认迟到。</li></ol><p><strong>连续 ARQ 协议</strong>：可提高信道利用率。<strong>发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。</strong>接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。<br><strong>优缺点：</strong><br><strong>优点</strong>： 信道利用率高，容易实现，即使确认丢失，也不必重传。<br><strong>缺点</strong>： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><h3 id="2-滑动窗口和流量控制"><a href="#2-滑动窗口和流量控制" class="headerlink" title="2. 滑动窗口和流量控制"></a>2. 滑动窗口和流量控制</h3><p><code>TCP</code> <strong>利用滑动窗口实现流量控制</strong>。流量控制是为了<strong>控制发送方发送速率</strong>，保证接收方来得及接收。<br>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3. 拥塞控制"></a>3. 拥塞控制</h3><p><strong>拥塞</strong>：在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。<br><strong>拥塞控制</strong>：防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。<br><strong>前提</strong>：网络能够承受现有的网络负荷。<br>拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。<br>流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。<br>为了进行拥塞控制，<code>TCP</code> 发送方要维持一个 <strong>拥塞窗口</strong>(cwnd) 的状态变量。<strong>拥塞控制窗口的大小</strong>取决于网络的<strong>拥塞程度</strong>，并且<strong>动态变化</strong>。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。<br><code>TCP</code> 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>(由小到大逐渐增大发送窗口) 、 <strong>拥塞避免</strong> (拥塞窗口 cwnd 缓慢增大)、<strong>快重传与快恢复</strong>(如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认)。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><h2 id="9-在浏览器中输入-url-地址-gt-gt-显示主页的过程-面试常客"><a href="#9-在浏览器中输入-url-地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="9. 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>9. 在浏览器中输入 url 地址 -&gt;&gt; 显示主页的过程(面试常客)</h2><p><img src="https://img-blog.csdnimg.cn/97097f90061f4943939debdf7f98432b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="浏览器输入url地址"></p><h2 id="10-各种协议与-HTTP-协议之间的关系"><a href="#10-各种协议与-HTTP-协议之间的关系" class="headerlink" title="10. 各种协议与 HTTP 协议之间的关系"></a>10. 各种协议与 HTTP 协议之间的关系</h2><p><img src="https://img-blog.csdnimg.cn/1a65e533a6b24aa8bc967a53b9eac122.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="协议关系"></p><h2 id="11-HTTP-是不保存状态的协议-如何保存用户状态？"><a href="#11-HTTP-是不保存状态的协议-如何保存用户状态？" class="headerlink" title="11. HTTP 是不保存状态的协议, 如何保存用户状态？"></a>11. HTTP 是不保存状态的协议, 如何保存用户状态？</h2><p><code>HTTP</code> 是一种不保存状态，即无状态（stateless）协议。也就是说 <code>HTTP</code> 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，**<code>Session</code> 的主要作用就是通过服务端记录用户的状态。**典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 <code>HTTP</code> 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 <code>Session</code>，过了时间限制，就会销毁这个 <code>Session</code>）。</p><p>在服务端保存 <code>Session</code> 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 <code>redis</code> 保存)。既然 <code>Session</code> 存放在服务器端，那么我们如何实现 <code>Session</code> 跟踪呢？大部分情况下，我们都是通过在 <code>Cookie</code> 中附加一个 <code>Session ID</code> 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办？</strong><br>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h2 id="12-Cookie-的作用是什么-和-Session-有什么区别？"><a href="#12-Cookie-的作用是什么-和-Session-有什么区别？" class="headerlink" title="12. Cookie 的作用是什么? 和 Session 有什么区别？"></a>12. Cookie 的作用是什么? 和 Session 有什么区别？</h2><p><code>Cookie</code> 和 <code>Session</code> 都是用来<strong>跟踪浏览器用户身份的会话方式</strong>，但是两者的应用场景不太一样。</p><ul><li><p><code>Cookie</code> 一般用来<strong>保存用户信息</strong> 比如 ① 我们在 <code>Cookie</code> 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；② 一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 <code>Token</code> 在 <code>Cookie</code> 中，下次登录的时候只需要根据 <code>Token</code> 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③ 登录一次网站后访问网站其他页面不需要重新登录。<br><code>Session</code> 的主要作用就是<strong>通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 <code>HTTP</code> 协议是无状态的。服务端给特定的用户创建特定的 <code>Session</code> 之后就可以标识这个用户并且跟踪这个用户了。</p></li><li><p><code>Cookie</code> 数据保存在<strong>客户端</strong>(浏览器端)，<code>Session</code> 数据保存在<strong>服务器</strong>端。</p></li><li><p><code>Cookie</code> 存储在客户端中，而 <code>Session</code> 存储在服务器上，相对来说 <code>Session</code> <strong>安全性</strong>更高。如果要在 <code>Cookie</code> 中存储一些敏感信息，不要直接写入 <code>Cookie</code> 中，最好能将 <code>Cookie</code> 信息加密，然后使用到的时候再去服务器端解密。</p><h2 id="13-URI-和-URL-的区别是什么？"><a href="#13-URI-和-URL-的区别是什么？" class="headerlink" title="13. URI 和 URL 的区别是什么？"></a>13. URI 和 URL 的区别是什么？</h2></li><li><p><code>URI</code>(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p></li><li><p><code>URL</code>(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 <code>URI</code>，即 <code>URL</code> 可以用来标识一个资源，而且还指明了如何 locate 这个资源。<br><code>URI</code> 的作用像身份证号一样，<code>URL</code> 的作用更像家庭住址一样。<code>URL</code> 是一种具体的 <code>URI</code>，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p></li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/89c59e23b1a84ba0910c55e1550f4fd9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础知识笔记</title>
      <link href="/2022/03/10/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/10/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h2 id="1-Java-语言有哪些特点"><a href="#1-Java-语言有哪些特点" class="headerlink" title="1. Java 语言有哪些特点?"></a>1. Java 语言有哪些特点?</h2><p>1.简单易学；2. 面向对象（封装，继承，多态）；3.平台无关性（ Java 虚拟机实现平台无关性）；4.支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；5.可靠性；6.安全性；7.支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；8.编译与解释并存；<br>“Write Once, Run Anywhere（一次编写，随处运行）”是最大优势。</p><h2 id="2-JVM-vs-JRE-vs-JDK"><a href="#2-JVM-vs-JRE-vs-JDK" class="headerlink" title="2. JVM vs JRE vs JDK"></a>2. JVM vs JRE vs JDK</h2><p><strong>JVM</strong>：运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<strong>字节码和不同系统的 JVM 实现</strong>是 Java 语言“一次编译，随处可以运行”的关键所在。<br><strong>JRE</strong>： Java 运行时环境。<strong>JRE&#x3D;JVM+java类库、java命令、其他一些基础构建</strong>（它是运行已编译 Java 程序所需的所有内容的集合）<br><strong>JDK</strong>：能够创建和编译程序。<strong>JDK &#x3D; JRE + 编译器（javac）和工具（如 javadoc 和 jdb）</strong></p><h2 id="3-什么是字节码-采用字节码的好处是什么"><a href="#3-什么是字节码-采用字节码的好处是什么" class="headerlink" title="3. 什么是字节码?采用字节码的好处是什么?"></a>3. 什么是字节码?采用字节码的好处是什么?</h2><p><strong>字节码</strong>：JVM 可以理解的代码（.class 的文件）。<strong>不面向任何特定的处理器，只面向虚拟机</strong>。<br><strong>好处</strong>：通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低</strong>的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于<strong>字节码并不针对一种特定的机器</strong>，因此，Java 程序<strong>无须重新编译便可在</strong>多种不同操作系统的计算机上运行。<br><img src="https://img-blog.csdnimg.cn/bd44a5a004964c8fa637058872982ed2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_16,color_FFFFFF,t_70,g_se,x_16" alt="JAVA程序从源代码到运行"></p><h2 id="4-为什么说-Java-语言“编译与解释并存”？"><a href="#4-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="4. 为什么说 Java 语言“编译与解释并存”？"></a>4. 为什么说 Java 语言“编译与解释并存”？</h2><p><strong>编译型</strong> ：编译型语言会通过<strong>编译器</strong>将<strong>源代码一次性翻译成</strong>可被该平台执行的<strong>机器码</strong>。(执行快开发慢，C、C++、Go、Rust)<br><strong>解释型</strong> ：解释型语言会通过<strong>解释器一句一句</strong>的将代码解释为机器码后再执行。(执行慢开发快，Python、JavaScript、PHP)<br>Java 程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。既具有编译型语言的特征，也具有解释型语言的特征。<br><img src="https://img-blog.csdnimg.cn/16732eb6e12e47478c3e22bf40dc0e8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_12,color_FFFFFF,t_70,g_se,x_16" alt="编译器与解释器"><br>扩展：<strong>即时编译</strong>：混合了编译语言与解释型语言的优点。先把程序源代码编译成字节码，到执行期时，再将字节码直译，之后执行</p><h2 id="5-Oracle-JDK-vs-OpenJDK"><a href="#5-Oracle-JDK-vs-OpenJDK" class="headerlink" title="5. Oracle JDK vs OpenJDK"></a>5. Oracle JDK vs OpenJDK</h2><ol><li>发布时间：Oracle 6个月，open 3个月。</li><li>开源：Oracle 不完全开源，是open(开源)的一个实现</li><li>稳定：Oracle 更稳定。二者代码几乎相同。</li><li>响应性和JVM性能：Oracle 更好</li><li>获取：Oracle 不提供新版本支持</li><li>协议：Oracle BCL&#x2F;OTN协议（商用），open GPL v2协议<h2 id="6-Java-和-C-的区别"><a href="#6-Java-和-C-的区别" class="headerlink" title="6. Java 和 C++ 的区别?"></a>6. Java 和 C++ 的区别?</h2></li><li>Java <strong>不提供指针</strong>来直接访问内存，程序<strong>内存更加安全</strong></li><li>Java 的<strong>类是单继承</strong>的，C++ 支持多重继承；但是Java<strong>接口可以多继承</strong>。</li><li>Java 有<strong>自动内存管理垃圾回收机制</strong>(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持<strong>方法重载</strong>（操作符重载增加了复杂性）<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="1-字符型常量和字符串常量的区别"><a href="#1-字符型常量和字符串常量的区别" class="headerlink" title="1. 字符型常量和字符串常量的区别?"></a>1. 字符型常量和字符串常量的区别?</h2></li><li><strong>形式</strong>：字符常量 <strong>单引号</strong> 一个字符，字符串常量 <strong>双引号</strong> 多字符</li><li><strong>含义</strong>：字符常量相当于一个<strong>整型值</strong>( ASCII 值)，可以参加表达式运算；字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量(char)只占 <strong>2 个字节</strong>; 字符串常量占若干个字节。<h2 id="2-注释有哪几种形式？"><a href="#2-注释有哪几种形式？" class="headerlink" title="2. 注释有哪几种形式？"></a>2. 注释有哪几种形式？</h2>单行注释；多行注释；文档注释。<h2 id="3-标识符和关键字的区别是什么？"><a href="#3-标识符和关键字的区别是什么？" class="headerlink" title="3. 标识符和关键字的区别是什么？"></a>3. 标识符和关键字的区别是什么？</h2><strong>标识符</strong>：为程序、类、变量、方法等取的名字。<br><strong>关键字</strong>：被赋予特殊含义的标识符。Java 语言已经赋予了其特殊的含义，只能用于特定的地方。<table><thead><tr><th>分类</th><th>关键字</th></tr></thead><tbody><tr><td>访问控制</td><td>private  protected  public</td></tr><tr><td>类，方法和变量修饰符</td><td>abstractclassextendsfinalimplementsinterfacenative newstaticstrictfpsynchronizedtransientvolatileenum</td></tr><tr><td>程序控制</td><td>breakcontinuereturndowhileifelseforinstanceofswitchcasedefaultassert</td></tr><tr><td>错误处理</td><td>trycatchthrowthrowsfinally</td></tr><tr><td>包相关</td><td>importpackage</td></tr><tr><td>基本类型</td><td>booleanbytechardoublefloatintlong short</td></tr><tr><td>变量引用</td><td>superthisvoid</td></tr><tr><td>保留字</td><td>gotoconst</td></tr></tbody></table><h2 id="4-自增自减运算符"><a href="#4-自增自减运算符" class="headerlink" title="4. 自增自减运算符"></a>4. 自增自减运算符</h2>当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。<h2 id="5-continue、break-和-return-的区别是什么？"><a href="#5-continue、break-和-return-的区别是什么？" class="headerlink" title="5. continue、break 和 return 的区别是什么？"></a>5. continue、break 和 return 的区别是什么？</h2><code>continue</code>：指跳出<strong>当前循环</strong>，继续下一次循环<br><code>break</code>：指跳出<strong>整个循环体</strong>，继续执行循环下面的语句<br><code>return</code>：用于跳出<strong>所在方法</strong>，结束该方法的运行。</li><li><code>return;</code>  直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value</code>  return 一个特定值，用于有返回值函数的方法<h2 id="6-方法：什么是方法的返回值-方法有哪几种类型？"><a href="#6-方法：什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="6. 方法：什么是方法的返回值?方法有哪几种类型？"></a>6. 方法：什么是方法的返回值?方法有哪几种类型？</h2><strong>方法的返回值</strong>：获取到的某个方法体中的代码<strong>执行后产生的结果</strong>！<br>1.无参数无返回值的方法；2.有参数无返回值的方法<br>3.有返回值无参数的方法；4.有返回值有参数的方法<h2 id="7-静态方法为什么不能调用非静态成员-结合-JVM-的相关知识"><a href="#7-静态方法为什么不能调用非静态成员-结合-JVM-的相关知识" class="headerlink" title="7. 静态方法为什么不能调用非静态成员?(结合 JVM 的相关知识)"></a>7. 静态方法为什么不能调用非静态成员?(结合 JVM 的相关知识)</h2></li><li>静态方法是<strong>属于类</strong>的，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。而非静态成员属于<strong>实例对象</strong>，只有在<strong>对象实例化之后才存在</strong>，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。<h2 id="8-静态方法和实例方法有何不同？"><a href="#8-静态方法和实例方法有何不同？" class="headerlink" title="8. 静态方法和实例方法有何不同？"></a>8. 静态方法和实例方法有何不同？</h2></li><li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用<code>对象.方法名</code>的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</li><li><strong>访问类成员是否存在限制</strong>：<code>静态方法在访问本类的成员时，只允许访问静态成员</code>（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。<h2 id="9-重载和重写的区别"><a href="#9-重载和重写的区别" class="headerlink" title="9. 重载和重写的区别"></a>9. 重载和重写的区别</h2><strong>重载</strong>：同一个类中多个<strong>同名方法</strong>根据<strong>不同的传参</strong>来执行<strong>不同的逻辑</strong>处理。<br>（发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。）**(编译期)**<br><strong>重写</strong>：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。（<strong>运行期</strong>）<br>方法的重写要遵循“<strong>两同两小一大</strong>”：</li><li>两同：<code>方法名</code>、<code>形参列表</code></li><li>两小：子类方法<code>返回值类型</code>、<code>声明抛出的异常类</code>  比父类方法更小或相等</li><li>一大：子类方法的<code>访问权限</code>应比父类方法的访问权限更大或相等<h2 id="10-x3D-x3D-和-equals-的区别"><a href="#10-x3D-x3D-和-equals-的区别" class="headerlink" title="10. &#x3D;&#x3D; 和 equals() 的区别"></a>10. &#x3D;&#x3D; 和 equals() 的区别</h2></li><li><strong>基本数据类型</strong>，<code>==</code> 比较的是<strong>值</strong>。<br><strong>引用数据类型</strong>，<code>== </code>比较的是对象的<strong>内存地址</strong>。</li><li><code> equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<br>(<code>equals()</code>未重写等价与<code>==</code>，重写后如上）</li><li><code>Java 只有值传递</code>，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。<h2 id="11-hashCode-与-equals"><a href="#11-hashCode-与-equals" class="headerlink" title="11. hashCode() 与 equals()"></a>11. hashCode() 与 equals()</h2></li><li>hashCode() 有什么用？<br>获取哈希码（int 整数），也称为散列码。哈希码作用是确定该对象在哈希表中的<strong>索引位置</strong>。</li><li>为什么要有 hashCode？<br>对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode值</code> 来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode 值</code>作比较。<br>如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。<br>如果发现有相同 <code>hashCode 值</code>的对象，这时会调用 <code>equals() 方法</code>来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等</li><li>那为什么 JDK 还要同时提供这两个方法呢？<br>同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</li><li>那为什么不只提供 hashCode() 方法呢？<br>两个对象的<code>hashCode 值</code>相等并不代表两个对象就相等</li><li>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？<br>哈希算法也许刚好会让多个对象传回相同的哈希值(哈希碰撞)</li><li>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？<br>两个相等的对象的 hashCode 值必须是相等<br><strong>总结</strong>：</li><li>如果两个对象的<code>hashCode 值</code>相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode 值</code>相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode 值</code>不相等，我们就可以直接认为这两个对象不相等。<h2 id="12-什么是可变长参数？"><a href="#12-什么是可变长参数？" class="headerlink" title="12. 什么是可变长参数？"></a>12. 什么是可变长参数？</h2>允许在调用方法时传入不定长度的参数。<br>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？<br><strong>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</strong><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="1-Java-中的8种基本数据类型了解么"><a href="#1-Java-中的8种基本数据类型了解么" class="headerlink" title="1. Java 中的8种基本数据类型了解么?"></a>1. Java 中的8种基本数据类型了解么?</h2></li><li>6 种<strong>数字类型</strong>：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>(4 种<strong>整数型)<strong>、<code>float</code>、<code>double</code>(2 种浮</strong>点型</strong>)</li><li>1 种<strong>字符类型</strong>：<code>char</code></li><li>1 种<strong>布尔型</strong>：<code>boolean</code></li></ol><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code><br>包装类型不赋值就是 <code>Null</code> ，而基本类型有默认值且不是 <code>Null</code><br>(基本数据类型直接存放在 Java 虚拟机栈中的<strong>局部变量表</strong>中，而包装类型属于对象类型，我们知道<strong>对象实例都存在于堆</strong>中。相比于对象类型， 基本数据类型占用的空间非常小。)<br><img src="https://img-blog.csdnimg.cn/3519514622cb465394087dc5a3e87067.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="2-包装类型的常量池技术了解么？"><a href="#2-包装类型的常量池技术了解么？" class="headerlink" title="2. 包装类型的常量池技术了解么？"></a>2. 包装类型的常量池技术了解么？</h2><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>。<br><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。浮点型没有实现常量池技术。</p><ol><li>所有整型包装类对象之间值的比较，全部使用 equals 方法比较<br><img src="https://img-blog.csdnimg.cn/ae16a30e0f4744f58a3bc1551ff94dbb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="3-自动装箱与拆箱了解吗？原理是什么？"><a href="#3-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="3. 自动装箱与拆箱了解吗？原理是什么？"></a>3. 自动装箱与拆箱了解吗？原理是什么？</h2></li><li>什么是自动拆装箱？<br><strong>装箱</strong>：将<strong>基本类型</strong>用对应的<strong>引用类型</strong>包装起来；<br><strong>拆箱</strong>：将<strong>包装类型</strong>转换为<strong>基本数据类型</strong>；</li><li>原理：从字节码中，我们发现<strong>装箱</strong>其实就是调用了 包装类的<code>valueOf()方法</code>，拆箱其实就是调用了 <code>xxxValue()</code>方法。<br><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code><br><code>int n = i</code> 等价于 <code>int n = i.intValue()</code><br>频繁拆装箱的话，也会严重影响系统的性能。尽量避免不必要的拆装箱操作。</li></ol><h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p>区别在于<strong>解决问题的方式</strong>不同。<br><strong>面向过程</strong>：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题<br><strong>面向对象</strong>：先抽象出对象，然后用对象执行方法的方式解决问题。<br>面向对象开发的程序一般更易<strong>维护</strong>、易<strong>复用</strong>、易<strong>扩展</strong></p><h2 id="2-成员变量与局部变量的区别有哪些？"><a href="#2-成员变量与局部变量的区别有哪些？" class="headerlink" title="2. 成员变量与局部变量的区别有哪些？"></a>2. 成员变量与局部变量的区别有哪些？</h2><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值<h2 id="3-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#3-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="3. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>3. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。<br>一个对象引用可以指向 0 个或 1 个对象；一个对象可以有 n 个引用指向它。<h2 id="4-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#4-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="4. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>4. 对象的相等与指向他们的引用相等,两者有什么不同?</h2></li><li>对象的相等一般比较的是内存中存放的<strong>内容</strong>是否相等。</li><li>引用相等一般比较的是他们指向的<strong>内存地址</strong>是否相等。<h2 id="5-一个类的构造方法的作用是什么"><a href="#5-一个类的构造方法的作用是什么" class="headerlink" title="5. 一个类的构造方法的作用是什么?"></a>5. 一个类的构造方法的作用是什么?</h2>构造方法是一种特殊的方法，主要作用是<strong>完成对象的初始化工作</strong>。<h2 id="6-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#6-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="6. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>6. 如果一个类没有声明构造方法，该程序能正确执行吗?</h2>可以。一个类没有声明构造方法，也会有<strong>默认的不带参数的构造方法</strong>。<br>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了。<br>创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来。</li></ul><h2 id="7-构造方法有哪些特点？是否可被-override"><a href="#7-构造方法有哪些特点？是否可被-override" class="headerlink" title="7. 构造方法有哪些特点？是否可被 override?"></a>7. 构造方法有哪些特点？是否可被 override?</h2><p>构造方法特点如下：</p><ol><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><p>构造方法<strong>不能被 override（重写）</strong>,但是<strong>可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p><h2 id="8-面向对象三大特征"><a href="#8-面向对象三大特征" class="headerlink" title="8. 面向对象三大特征"></a>8. 面向对象三大特征</h2><ol><li><strong>封装</strong>。把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</li><li><strong>继承</strong>。 使用<strong>已存在的类</strong>的定义作为<strong>基础</strong>建立<strong>新类</strong>的技术，新类的定义可以<strong>增加新的数据或新的功能</strong>，也可以用父类的功能，但不能选择性地继承父类。<br>2.1 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。<br>2.2 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>2.3 子类可以用自己的方式实现父类的方法。</li><li><strong>多态</strong>。表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<br>3.1 对象类型和引用类型之间具有<strong>继承</strong>（类）&#x2F;实现（接口）的关系；<br>3.2 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；<br>3.3 多态不能调用“只在子类存在但在父类不存在”的方法；<br>3.4 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法<h2 id="9-接口和抽象类有什么共同点和区别？"><a href="#9-接口和抽象类有什么共同点和区别？" class="headerlink" title="9. 接口和抽象类有什么共同点和区别？"></a>9. 接口和抽象类有什么共同点和区别？</h2><strong>共同点</strong>：</li><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。</li></ol><p><strong>区别</strong>：</p><ol><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值.<h2 id="10-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#10-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="10. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>10. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><strong>深拷贝</strong>：深拷贝会完全<strong>复制整个对象</strong>，包括这个对象所包含的内部对象。<br><strong>浅拷贝</strong>：在堆上创建一个<strong>新对象</strong>。原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址。<br><strong>引用拷贝</strong>：两个不同的引用指向<strong>同一个对象</strong>。<br><img src="https://img-blog.csdnimg.cn/img_convert/5089a086b18f8e3cb26ed513c79f1edd.png" alt="拷贝"><h1 id="Java常见对象"><a href="#Java常见对象" class="headerlink" title="Java常见对象"></a>Java常见对象</h1><h2 id="1-Object-类的常见方法有哪些？"><a href="#1-Object-类的常见方法有哪些？" class="headerlink" title="1. Object 类的常见方法有哪些？"></a>1. Object 类的常见方法有哪些？</h2>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"><span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure><h2 id="2-String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的"><a href="#2-String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的" class="headerlink" title="2. String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?"></a>2. String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</li><li>保存字符串的数组被 <code>final</code> <strong>修饰且为私有的</strong>，并且<code>String</code> 类<strong>没有提供&#x2F;暴露</strong>修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其<strong>不能被继承</strong>，进而避免了子类破坏 <code>String</code> 不可变。<br>(final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象)</li></ol><p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><code>String</code> 中的<strong>对象是不可变</strong>的，也就可以理解为常量，<strong>线程安全</strong>。<br><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法<strong>加了同步锁</strong>，所以是<strong>线程安全</strong>的。<br><code>StringBuilder</code> 并<strong>没有</strong>对方法进行<strong>加同步锁</strong>，所以是非线程安全的。<br>（<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。）</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>String</code>：每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<br><code>StringBuffer</code>：每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。<br><code>StringBuilder</code>：相比<code>StringBuffer</code>获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>String</code>：操作<strong>少量</strong>的数据<br><code>StringBuffer</code>：<strong>多线程</strong>操作字符串缓冲区下操作大量数据<br><code>StringBuilder</code>：<strong>单线程</strong>操作字符串缓冲区下操作大量数据</p><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#1-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="1. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>1. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h2><p><strong>泛型</strong>：泛型提供了编译时<strong>类型安全检测</strong>机制，该机制允许程序员在<strong>编译时检测到非法的类型</strong>。<br>泛型的本质是参数化类型，所操作的数据类型被指定为一个参数。<br><strong>类型擦除</strong>：Java 的泛型是<strong>伪泛型</strong>，在<strong>运行期间</strong>，<strong>所有的泛型信息都会被擦掉</strong>。<br>泛型一般有三种使用方式：<strong>泛型类、泛型接口、泛型方法</strong>。<br><strong>通配符</strong>：T，E，K，V，？</p><ul><li>？ 表示不确定的 Java 类型</li><li>T (type) 表示具体的一个 Java 类型</li><li>K V (key value) 分别代表 Java 键值中的 Key Value</li><li>E (element) 代表 Element<br><strong>你的项目中哪里用到了泛型？</strong></li><li>可用于定义通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li><li>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</li><li>用于构建集合工具类。参考 <code>Collections</code> 中的 sort, binarySearch 方法<br>……<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-何为反射"><a href="#1-何为反射" class="headerlink" title="1. 何为反射"></a>1. 何为反射</h2>反射被称为框架的灵魂，赋予了我们在运行时<strong>分析类以及执行类中方法的能力</strong>。<br>通过反射你可以<strong>获取任意一个类的所有属性和方法</strong>，<strong>还可以调用这些方法和属性</strong>。<h2 id="2-反射机制优缺点"><a href="#2-反射机制优缺点" class="headerlink" title="2. 反射机制优缺点"></a>2. 反射机制优缺点</h2></li><li><strong>优点</strong> ： 可以让咱们的<strong>代码更加灵活</strong>、为各种框架提供<strong>开箱即用</strong>的功能提供了便利</li><li><strong>缺点</strong> ：让我们在<strong>运行时有了分析操作类的能力</strong>，这同样也增加了<strong>安全问题</strong>。比如可以<strong>无视泛型参数的安全检查</strong>（泛型参数的安全检查发生在编译时）。另外，反射的<strong>性能也稍差</strong>点，不过，对于框架来说实际是影响不大的。<h2 id="3-反射的应用场景"><a href="#3-反射的应用场景" class="headerlink" title="3. 反射的应用场景"></a>3. 反射的应用场景</h2><code>Spring/Spring Boot</code>、<code>MyBatis</code> 等等框架中都大量使用了反射机制。<br>这些框架中也大量使用了<strong>动态代理</strong>，而动态代理的<strong>实现依赖反射</strong>。<h2 id="4-获取-Class-对象的四种方式"><a href="#4-获取-Class-对象的四种方式" class="headerlink" title="4. 获取 Class 对象的四种方式"></a>4. 获取 Class 对象的四种方式</h2>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象：</li></ul><ol><li>知道<strong>具体类</strong>的情况下可以使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</li><li>通过 <code>Class.forName()</code>传入类的全路径获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>通过<strong>对象实例</strong><code>instance.getClass()</code>获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure></li><li>通过<strong>类加载器</strong><code>xxxClassLoader.loadClass()</code>传入类路径获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行<h2 id="5-反射的一些基本操作"><a href="#5-反射的一些基本操作" class="headerlink" title="5. 反射的一些基本操作"></a>5. 反射的一些基本操作</h2></li><li>创建一个我们要使用反射操作的类 TargetObject</li><li>使用反射操作这个类的方法以及参数<h1 id="注解Annontation"><a href="#注解Annontation" class="headerlink" title="注解Annontation"></a>注解<code>Annontation</code></h1><strong>注解</strong>：本质是一个继承了<code>Annotation</code> 的<strong>特殊接口</strong><br>注解只有被解析之后才会生效，常见的解析方法有两种：</li></ol><ul><li><strong>编译期直接扫描</strong> ：编译器在<strong>编译 Java 代码的时候</strong>扫描对应的注解并处理。比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li><li><strong>运行期通过反射处理</strong>：像<strong>框架</strong>中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><strong>Java 异常类层次结构图概览 ：</strong><br><img src="https://img-blog.csdnimg.cn/1655c39e8eaf44029950d71d82bc9b3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="1-Exception-和-Error-有什么区别？"><a href="#1-Exception-和-Error-有什么区别？" class="headerlink" title="1. Exception 和 Error 有什么区别？"></a>1. Exception 和 Error 有什么区别？</h2>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable 类</code>。<code>Throwable 类</code>有两个重要的子类：<br><code>Exception</code>：<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <code>Checked Exception</code> (受检查异常，必须处理) 和 <code>Unchecked Exception</code> (不受检查异常，可以不处理)。<br><code>Error</code>：<code>Error</code>属于<strong>程序无法处理的错误</strong> ，我们没办法通过<code>catch</code>来进行捕获不建议通过<code>catch</code>捕获 。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。<h2 id="2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 有什么区别？"></a>2. Checked Exception 和 Unchecked Exception 有什么区别？</h2> <strong><code>Checked Exception</code> (受检查异常，必须处理)<strong>：Java 代码在编译过程中，如果受检查异常没有被 <strong>catch&#x2F;throw 处理</strong>的话，就没办法通过编译 。<br><strong><code>Unchecked Exception</code> (不受检查异常，可以不处理)<strong>：Java 代码在编译过程中 ，我们即使</strong>不处理</strong>不受检查异常</strong>也可以正常通过编译</strong>。<h2 id="3-Throwable-类常用方法有哪些？"><a href="#3-Throwable-类常用方法有哪些？" class="headerlink" title="3. Throwable 类常用方法有哪些？"></a>3. Throwable 类常用方法有哪些？</h2></li><li><code>String getMessage()</code>：返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li><li><code>void printStackTrace()</code>：在控制台上打印 Throwable 对象封装的异常信息<h2 id="4-try-catch-finally-如何使用？"><a href="#4-try-catch-finally-如何使用？" class="headerlink" title="4. try-catch-finally 如何使用？"></a>4. try-catch-finally 如何使用？</h2><code>try</code>块： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个<code>finally</code> 块。<br><code>catch</code>块： 用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code> 块： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，finally 语句块将在方法返回之前被执行。<br><strong>注意</strong>：<strong>不要在 finally 语句块中使用 return</strong>! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。<h2 id="5-finally-中的代码一定会执行吗？"><a href="#5-finally-中的代码一定会执行吗？" class="headerlink" title="5. finally 中的代码一定会执行吗？"></a>5. finally 中的代码一定会执行吗？</h2>不一定的！在某些情况下，<code>finally</code> 中的代码不会被执行。</li></ul><ol><li>比如说 <code>finally</code> 之前虚拟机被终止运行</li><li>程序所在的线程死亡</li><li>关闭 CPU<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="1-什么是序列化？什么是反序列化？"><a href="#1-什么是序列化？什么是反序列化？" class="headerlink" title="1. 什么是序列化？什么是反序列化？"></a>1. 什么是序列化？什么是反序列化？</h2></li></ol><ul><li><strong>序列化</strong>： 将<strong>数据结构或对象</strong>转换成<strong>二进制字节流</strong>的过程</li><li><strong>反序列化</strong>：将在序列化过程中所生成的<strong>二进制字节流</strong>转换成<strong>数据结构或者对象</strong>的过程<br><strong>序列化的主要目的</strong>：通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中<br>对于 Java 面向对象编程语言，<strong>序列化的都是对象</strong>（Object），也就是实例化后的类(Class)，<br> C++这种半面向对象的语言中，struct(结构体)定义的是<strong>数据结构类型</strong>，而 class 对应的是对象类型。<h2 id="2-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2. Java 序列化中如果有些字段不想进行序列化，怎么办？</h2>使用 <code>transient</code> 关键字修饰。<br><strong><code>transient</code> 关键字的作用是</strong>：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。<h2 id="3-获取用键盘输入常用的两种方法"><a href="#3-获取用键盘输入常用的两种方法" class="headerlink" title="3. 获取用键盘输入常用的两种方法"></a>3. 获取用键盘输入常用的两种方法</h2></li></ul><ol><li>通过 <code>Scanner</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li><li>通过 <code>BufferedReader</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure><h2 id="4-Java-中-IO-流分为几种"><a href="#4-Java-中-IO-流分为几种" class="headerlink" title="4. Java 中 IO 流分为几种?"></a>4. Java 中 IO 流分为几种?</h2></li></ol><ul><li>按照流的<strong>流向</strong>：输入流    输出流</li><li>按照操作<strong>单元</strong>：字节流    字符流</li><li>按照流的<strong>角色</strong>：节点流    处理流<h2 id="5-既然有了字节流-为什么还要有字符流"><a href="#5-既然有了字节流-为什么还要有字符流" class="headerlink" title="5. 既然有了字节流,为什么还要有字符流?"></a>5. 既然有了字节流,为什么还要有字符流?</h2><strong>本质</strong>：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？<br><strong>字符流</strong>是由 Java 虚拟机将<strong>字节转换得到</strong>的，这个过程<strong>① 非常耗时</strong>，<strong>② 不知道编码类型易乱码问题</strong>。<br>所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。<br><strong>音频文件、图片</strong>等媒体文件用字节流比较好。<br><strong>涉及到字符</strong>的话使用字符流比较好。<h1 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h1><h2 id="1-形参-amp-实参"><a href="#1-形参-amp-实参" class="headerlink" title="1. 形参&amp;实参"></a>1. 形参&amp;实参</h2>方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：</li><li><strong>实参（实际参数）</strong>：用于<strong>传递</strong>给函数&#x2F;方法的参数，必须有确定的值。</li><li><strong>形参（形式参数）</strong>：用于<strong>定义</strong>函数&#x2F;方法，接收实参，不需要有确定的值<h2 id="2-值传递-amp-引用传递"><a href="#2-值传递-amp-引用传递" class="headerlink" title="2. 值传递&amp;引用传递"></a>2. 值传递&amp;引用传递</h2>程序设计语言将<strong>实参传递</strong>给方法（或函数）的方式分为两种：<br><strong>值传递</strong>：方法接收的是<strong>实参值</strong>的拷贝，会<strong>创建副本</strong>。<br><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在<strong>堆中的地址</strong>，<strong>不会创建副本</strong>，对形参的修改将影响到实参。<br>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>Java 中将<strong>实参传递给方法</strong>（或函数）的方式是 <strong>值传递</strong> ：<br>如果参数是<strong>基本类型</strong>的话：传递的就是<strong>基本类型的字面量值</strong>的拷贝，会创建副本。<br>如果参数是<strong>引用类型</strong>：传递的就是<strong>实参所引用的对象在堆中地址值</strong>的拷贝，同样也会创建副本。<h1 id="Java-代理模式详解"><a href="#Java-代理模式详解" class="headerlink" title="Java 代理模式详解"></a>Java 代理模式详解</h1><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2>使用<strong>代理对象</strong>来代替对真实对象(real object)的访问，到达在<strong>不修改原目标对象</strong>的前提下，<strong>扩展</strong>目标对象的额外的<strong>功能</strong>操作。（<strong>静态</strong>代理  <strong>动态</strong>代理）<h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2></li></ul><ol><li><strong>实现和应用角度</strong>：对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象<strong>都要进行修改</strong>）且麻烦(需要对每个目标类<strong>都单独写一个代理类</strong>)。 （现实几乎看不到）</li><li><strong>JVM 层面</strong>：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 <code>.class</code> 文件。</li><li>实现步骤：<br>3.1 <strong>定义</strong>一个<strong>接口</strong>及其<strong>实现类</strong>；<br>3.2 <strong>创建</strong>一个<strong>代理类</strong>同样<strong>实现这个接口</strong><br>3.3 将目标对象<strong>注入</strong>进代理类，然后在<strong>代理类</strong>的对应方法<strong>调用目标类</strong>中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2></li><li><strong>实现和应用角度</strong>：更加灵活。不需要针对每个目标类都单独创建一个代理类，也不需要必须实现接口，可以直接代理实现类( CGLIB 动态代理机制)。</li><li><strong>JVM 层面</strong>：动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。<h2 id="3-1-JDK-动态代理机制"><a href="#3-1-JDK-动态代理机制" class="headerlink" title="3.1 JDK 动态代理机制"></a>3.1 JDK 动态代理机制</h2><code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。<br><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。<br>这个方法一共有 3 个参数：</li><li><code>loader</code>：类加载器，用于加载代理对象。</li><li><code>interfaces</code>：被代理类实现的一些接口；</li><li><code>h</code>：实现了 InvocationHandler 接口的对象；</li></ol><p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。<br> <code>invoke()</code> 方法有下面三个参数：</p><ol><li><code>proxy</code> :动态生成的代理类</li><li><code>method</code> : 与代理类对象调用的方法相对应</li><li><code>args</code> : 当前 method 方法的参数</li></ol><p><strong>总结</strong>：通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p><ol><li>JDK 动态代理类使用步骤<br>1.1 定义一个接口及其实现类；<br>1.2 自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；<br>1.3 通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象</li></ol><h2 id="3-CGLIB-动态代理机制"><a href="#3-CGLIB-动态代理机制" class="headerlink" title="3. CGLIB 动态代理机制"></a>3. CGLIB 动态代理机制</h2><p>JDK 动态代理最致命的问题：<strong>只能代理实现了接口的类</strong>。（CGLIB动态代理机制）</p><ul><li><strong>CGLIB</strong>(Code Generation Library)是一个基于ASM的<strong>字节码生成库</strong>，在<strong>运行时</strong>对字节码进行<strong>修改和动态生成</strong>。</li><li><strong>CGLIB</strong> 通过<strong>继承方式</strong>实现代理。</li><li><strong>Spring</strong> 中的 <strong>AOP</strong> 模块中：如果目标对象<strong>实现了接口</strong>，则默认采用 <strong>JDK 动态代理</strong>，<strong>否则采用 CGLIB</strong> 动态代理。</li><li>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。<br>（需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于<strong>拦截增强被代理类的方法</strong>。）<br>（通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。）<h2 id="4-CGLIB-动态代理类使用步骤"><a href="#4-CGLIB-动态代理类使用步骤" class="headerlink" title="4. CGLIB 动态代理类使用步骤"></a>4. CGLIB 动态代理类使用步骤</h2></li></ul><ol><li>定义一个类；</li><li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li><li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；<h2 id="5-静态代理和动态代理的对比"><a href="#5-静态代理和动态代理的对比" class="headerlink" title="5. 静态代理和动态代理的对比"></a>5. 静态代理和动态代理的对比</h2></li><li><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li><li><strong>JVM 层面</strong>：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</li></ol><h1 id="I-x2F-O（Input-x2F-Outpu）-即输入／输出"><a href="#I-x2F-O（Input-x2F-Outpu）-即输入／输出" class="headerlink" title="I&#x2F;O（Input&#x2F;Outpu） 即输入／输出"></a>I&#x2F;O（Input&#x2F;Outpu） 即输入／输出</h1><p><strong>冯.诺依曼</strong>结构，计算机结构分为 5 大部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong><br> I&#x2F;O 描述了：<strong>计算机系统</strong>与<strong>外部设备</strong>之间通信的过程。<br><img src="https://img-blog.csdnimg.cn/830650cf4e0a417abad383dfe36ab280.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>为了<strong>保证操作系统的稳定性和安全性</strong>，一个进程的地址空间划分为 <strong>用户空间</strong>（User space） 和 <strong>内核空间</strong>（Kernel space ）。<br>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（<strong>系统调用</strong>），操作系统负责的<strong>内核执行具体的 IO 操作</strong>。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的<strong>内核完成</strong>的。</p><ol><li>内核等待 I&#x2F;O 设备准备好数据。</li><li>内核将数据从内核空间拷贝到用户空间。<h2 id="1-有哪些常见的-IO-模型"><a href="#1-有哪些常见的-IO-模型" class="headerlink" title="1. 有哪些常见的 IO 模型?"></a>1. 有哪些常见的 IO 模型?</h2>UNIX 系统下，IO 模型一共有 5 种： <strong>同步阻塞</strong> I&#x2F;O、<strong>同步非阻塞</strong> I&#x2F;O、I&#x2F;O <strong>多路复用</strong>、<strong>信号驱动</strong> I&#x2F;O 和<strong>异步</strong> I&#x2F;O。<h2 id="2-BIO-Blocking-I-x2F-O-（同步阻塞I-x2F-O模型）"><a href="#2-BIO-Blocking-I-x2F-O-（同步阻塞I-x2F-O模型）" class="headerlink" title="2. BIO (Blocking I&#x2F;O)（同步阻塞I&#x2F;O模型）"></a>2. BIO (Blocking I&#x2F;O)（同步阻塞I&#x2F;O模型）</h2><img src="https://img-blog.csdnimg.cn/efe6c639db6a4ded945075ea3bd26e66.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="3-NIO-Non-blocking-x2F-New-I-x2F-O-（-I-x2F-O-多路复用模型）"><a href="#3-NIO-Non-blocking-x2F-New-I-x2F-O-（-I-x2F-O-多路复用模型）" class="headerlink" title="3. NIO (Non-blocking&#x2F;New I&#x2F;O)（ I&#x2F;O 多路复用模型）"></a>3. NIO (Non-blocking&#x2F;New I&#x2F;O)（ I&#x2F;O 多路复用模型）</h2><img src="https://img-blog.csdnimg.cn/39d38f6393124b0e88c65235c5c2897f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据</strong>是否已经准备好的过程是十分<strong>消耗CPU</strong> 资源的。<br><img src="https://img-blog.csdnimg.cn/f1afbf2ae8a049de8da19640524ce15d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。<h2 id="4-AIO-Asynchronous-I-x2F-O-（异步I-x2F-O模型）"><a href="#4-AIO-Asynchronous-I-x2F-O-（异步I-x2F-O模型）" class="headerlink" title="4. AIO (Asynchronous I&#x2F;O)（异步I&#x2F;O模型）"></a>4. AIO (Asynchronous I&#x2F;O)（异步I&#x2F;O模型）</h2>基于<strong>事件和回调</strong>机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当<strong>后台处理完</strong>成，操作系统<strong>会通知</strong>相应的线程进行<strong>后续</strong>的操作。<br><img src="https://img-blog.csdnimg.cn/daaa57e82acf4a55bc1703d428b3f085.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5bc33936cd43453da9d882a5fd0e975c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt=" Java 中的 BIO、NIO、AIO"><h2 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a>BigDecimal 详解</h2><h2 id="1-BigDecimal-介绍"><a href="#1-BigDecimal-介绍" class="headerlink" title="1. BigDecimal 介绍"></a>1. BigDecimal 介绍</h2><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。<h2 id="2-为什么浮点数-float-或-double-运算的时候会有精度丢失的风险呢？"><a href="#2-为什么浮点数-float-或-double-运算的时候会有精度丢失的风险呢？" class="headerlink" title="2. 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？"></a>2. 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？</h2>计算机是二进制的，在表示一个数字时，<strong>宽度有限</strong>，无限循环的小数存储在计算机时，只能被<strong>截断</strong>，<h2 id="3-BigDecimal-常见方法"><a href="#3-BigDecimal-常见方法" class="headerlink" title="3. BigDecimal 常见方法"></a>3. BigDecimal 常见方法</h2></li></ol><ul><li>加减乘除：<code>add</code>、<code>subtract</code>、<code>multiply</code>、<code>divide</code></li><li>大小比较：<code>a.compareTo(b)</code></li><li>保留几位小数：<code>setScale</code><br><img src="https://img-blog.csdnimg.cn/737897a5fe46459391850bfd9ee563df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2>浮点数没有办法用二进制精确表示，因此存在<strong>精度丢失</strong>的风险。</li></ul><p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/2b8f367dfd9f4e0da66ce99b35ebc4be.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础知识整理</title>
      <link href="/2022/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2022/03/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h1><h2 id="1-什么是操作系统？"><a href="#1-什么是操作系统？" class="headerlink" title="1. 什么是操作系统？"></a>1. 什么是操作系统？</h2><ol><li>操作系统（Operating System，简称 OS）是<strong>管理</strong>计算机硬件与软件资源的<strong>程序</strong>，是计算机的基石。</li><li>操作系统本质上是一个运行在计算机上的<strong>软件程序</strong>，用于管理计算机硬件和软件资源。</li><li>操作系统存在<strong>屏蔽了硬件层</strong>的复杂性。 </li><li>操作系统的<strong>内核</strong>（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。<br><img src="https://img-blog.csdnimg.cn/dc03692aa61a4ce7a83608b5b6e9ab07.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="操作系统"></li></ol><h2 id="2-什么是系统调用？"><a href="#2-什么是系统调用？" class="headerlink" title="2. 什么是系统调用？"></a>2. 什么是系统调用？</h2><p>根据<strong>进程访问资源</strong>的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li><strong>用户态</strong>(user mode)：用户态运行的进程可以<strong>直接读取用户程序的数据</strong>。</li><li><strong>系统态</strong>(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以<strong>访问计算机的任何资源</strong>，不受限制。</li></ol><p>我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如<strong>设备管理、文件管理、进程管理、进程控制、内存管理</strong>等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="1-进程和线程的区别。"><a href="#1-进程和线程的区别。" class="headerlink" title="1. 进程和线程的区别。"></a>1. 进程和线程的区别。</h2><p>下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！<br>从下图可以看出：一个进程中可以有多个线程，<strong>多个线程共享进程的堆和方法区</strong> (JDK1.8 之后的元空间)资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。<br><strong>总结</strong>： 线程是进程划分成的更小的运行单位，一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为<strong>同一进程中的线程极有可能会相互影响</strong>。线程执行开销小，但不利于资源的管理和保护；而进程正相反。<br><img src="https://img-blog.csdnimg.cn/d4ac896851fa4f3eabe4fb7e40dbbc78.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_18,color_FFFFFF,t_70,g_se,x_16" alt="线程进程"></p><h2 id="2-进程有哪几种状态"><a href="#2-进程有哪几种状态" class="headerlink" title="2. 进程有哪几种状态?"></a>2. 进程有哪几种状态?</h2><p><strong>创建</strong>状态( <code>new</code> ) ：进程正在被创建，尚未到就绪状态。<br><strong>就绪</strong>状态( <code>ready</code> ) ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。<br><strong>运行</strong>状态( <code>running</code> ) ：进程正在处理器上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。<br><strong>阻塞</strong>状态( <code>waiting</code> ) ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。<br><strong>结束</strong>状态( <code>terminated</code> ) ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。<br><img src="https://img-blog.csdnimg.cn/6d3a4c94a6914a4780de47dab24ba1ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="进程"></p><h2 id="3-进程间的通信方式"><a href="#3-进程间的通信方式" class="headerlink" title="3. 进程间的通信方式"></a>3. 进程间的通信方式</h2><p>（进程间的通信常见的的有哪几种方式呢？）</p><ol><li><strong>管道&#x2F;匿名管道</strong>(Pipes) ：用于具有亲缘关系的<strong>父子进程</strong>间或者<strong>兄弟进程</strong>之间的通信。</li><li><strong>有名管道</strong>(Names Pipes) : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(first in first out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li><li><strong>信号</strong>(Signal) ：信号是一种比较复杂的通信方式，用于<strong>通知</strong>接收进程某个事件已经发生；</li><li><strong>消息队列</strong>(Message Queuing) ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是<strong>先进先出</strong>的原则。与管道（<strong>无名管道</strong>：只存在于<strong>内存</strong>中的文件；<strong>命名管道</strong>：存在于实际的<strong>磁盘介质或者文件系统</strong>）不同的是<strong>消息队列存放在内核</strong>中，<strong>只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。</strong>消息队列可以实现消息的<strong>随机查询</strong>,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li><li><strong>信号量</strong>(Semaphores) ：信号量是一个计数器，<strong>用于多进程对共享数据的访问</strong>，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li><li><strong>共享内存</strong>(Shared memory) ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠<strong>某种同步操作，如互斥锁和信号量</strong>等。可以说这是最有用的进程间通信方式。</li><li><strong>套接字</strong>(Sockets) : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的<strong>端点</strong>，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li></ol><h2 id="4-线程间的同步的方式"><a href="#4-线程间的同步的方式" class="headerlink" title="4. 线程间的同步的方式"></a>4. 线程间的同步的方式</h2><p>那线程间的同步的方式有哪些呢？<br><strong>线程同步</strong>是<strong>两个或多个共享关键资源的线程的并发执行</strong>。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p><ol><li><strong>互斥量</strong>(Mutex)：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li><li><strong>信号量</strong>(Semphares) ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>事件</strong>(Event) :Wait&#x2F;Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。<h2 id="5-进程的调度算法"><a href="#5-进程的调度算法" class="headerlink" title="5. 进程的调度算法"></a>5. 进程的调度算法</h2><strong>目的</strong>：为了确定首先执行哪个进程以及最后执行哪个进程以<strong>实现最大 CPU 利用率</strong></li><li>**先到先服务(FCFS)**调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li><li>**短作业优先(SJF)**的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。（照顾了短进程而忽略了长进程）</li><li><strong>时间片轮转</strong>调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。<br>4 <strong>多级反馈队列</strong>调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前被公认的一种较好的进程调度算法，UNIX 操作系统采取的便是这种调度算法。</li><li><strong>优先级</strong>调度 ： 为每个流程<strong>分配优先级</strong>，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。<h2 id="6-什么是死锁？"><a href="#6-什么是死锁？" class="headerlink" title="6. 什么是死锁？"></a>6. 什么是死锁？</h2>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</li></ol><h2 id="7-死锁的四个必要条件？"><a href="#7-死锁的四个必要条件？" class="headerlink" title="7. 死锁的四个必要条件？"></a>7. 死锁的四个必要条件？</h2><p>四个条件同时成立，那么就能引起死锁。（<strong>互斥、占有并等待、非抢占、循环等待</strong>）</p><ol><li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li><li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li><li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li><strong>循环等待</strong>：有一组等待进程 {P0, P1,…, Pn}， P0 等待的资源被 P1 占有，P1 等待的资源被 P2 占有，……，Pn-1 等待的资源被 Pn 占有，Pn 等待的资源被 P0 占有。</li></ol><h2 id="8-解决死锁的方法？"><a href="#8-解决死锁的方法？" class="headerlink" title="8. 解决死锁的方法？"></a>8. 解决死锁的方法？</h2><p><strong>预防，避免，检测和解除</strong>。</p><ol><li><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</li><li><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测，从而避免死锁的发生</strong></li><li><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</li><li><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</li></ol><h3 id="8-1-死锁的预防"><a href="#8-1-死锁的预防" class="headerlink" title="8.1 死锁的预防"></a>8.1 死锁的预防</h3><p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是<strong>行不通</strong>的。</p><p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 主存资源 和 处理器资源 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p><p>所以一般比较实用的 预防死锁的方法，是通过考虑破坏第二个条件和第四个条件。</p><ol><li><strong>静态分配策略</strong>（破坏第二个条件（占有并等待））<br>指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。<strong>进程要么占有所有的资源然后开始执行，要么不占有资源不执行。</strong></li><li><strong>层次分配策略</strong>（破坏第四个条件(循环等待)）<br>在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再<strong>申请较高一层</strong>的资源；<br>当一个进程要释放某层的一个资源时，必须先<strong>释放所占用的较高层的资源</strong>。</li></ol><p>（<strong>预防系统发生死锁 ，但是会导致 低效的进程运行 和 资源使用率</strong> 。）</p><h3 id="8-2-死锁的避免"><a href="#8-2-死锁的避免" class="headerlink" title="8.2 死锁的避免"></a>8.2 死锁的避免</h3><p>避免死锁算法 就是 <code>Dijkstra</code> 的<strong>银行家算法</strong>，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p><p>(<strong>死锁的避免(银行家算法)改善解决了 资源使用率低的问题 ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 安全性检查 ，需要花费较多的时间</strong>)</p><h3 id="8-3-死锁的检测"><a href="#8-3-死锁的检测" class="headerlink" title="8.3 死锁的检测"></a>8.3 死锁的检测</h3><p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。<br>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测” 的程序</strong>，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。<br><img src="https://img-blog.csdnimg.cn/88f57519e9bf4dfd80aaf2e829e2653c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="等待资源的环路"><br>图中 2-21 是 <strong>进程-资源分配图</strong> 的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p><p>图 2-22 便是一个<strong>有环路而无死锁</strong>的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p><p><strong>死锁检测步骤</strong><br>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p><ol><li>如果进程-资源分配图中<strong>无环路</strong>，则此时系统没有发生死锁</li><li>如果进程-资源分配图中<strong>有环路</strong>，且<strong>每个资源类仅有一个资源</strong>，则系统中已经发生了死锁。</li><li>如果进程-资源分配图中<strong>有环路</strong>，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)<h3 id="8-4-死锁的解除"><a href="#8-4-死锁的解除" class="headerlink" title="8.4 死锁的解除"></a>8.4 死锁的解除</h3>让其解除，让系统从死锁状态中恢复过来。</li><li><strong>立即结束<del>所有进程</del> 的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li><li><strong>撤销涉及<del>死锁</del> 的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破死锁的循环等待条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li><li><strong><del>逐个撤销</del> 涉及死锁的进程，回收其资源直至死锁解除</strong>。</li><li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li></ol><h1 id="操作系统内存管理基础"><a href="#操作系统内存管理基础" class="headerlink" title="操作系统内存管理基础"></a>操作系统内存管理基础</h1><h2 id="1-操作系统的内存管理主要是做什么？（内存分配回收和地址转换）"><a href="#1-操作系统的内存管理主要是做什么？（内存分配回收和地址转换）" class="headerlink" title="1. 操作系统的内存管理主要是做什么？（内存分配回收和地址转换）"></a>1. 操作系统的内存管理主要是做什么？（内存分配回收和地址转换）</h2><p>主要负责<strong>内存的分配与回收</strong>（malloc 函数：申请内存，free 函数：释放内存），另外<strong>地址转换</strong>也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p><h2 id="2-常见的内存管理机制有几种？"><a href="#2-常见的内存管理机制有几种？" class="headerlink" title="2. 常见的内存管理机制有几种？"></a>2. 常见的内存管理机制有几种？</h2><p>连续分配管理方式（<strong>块式管理</strong>）和非连续分配管理方式（<strong>页式管理</strong> 和 <strong>段式管理</strong>）<br><strong>块式管理</strong>：远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。<br><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。<strong>页式管理通过页表对应逻辑地址和物理地址</strong>。<br><strong>段式管理</strong>：页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 <strong>段式管理通过段表对应逻辑地址和物理地址</strong>。<br><strong>段页式管理机制</strong>：段页式管理机制<strong>结合了段式管理和页式管理</strong>的优点。简单来说段页式管理机制就是把<strong>主存先分成若干段，每个段又分成若干页</strong>，也就是说 段页式管理机制 中段与段之间以及段的内部的都是离散的。<br>（页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。）</p><h2 id="3-快表和多级页表"><a href="#3-快表和多级页表" class="headerlink" title="3. 快表和多级页表"></a>3. 快表和多级页表</h2><p><strong>快表</strong><br>为了解决虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。<br>使用快表之后的地址转换流程是这样的：</p><ol><li>根据虚拟地址中的页号查快表；</li><li>如果该页在快表中，直接从快表中读取相应的物理地址；</li><li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><p><strong>多级页表</strong><br>引入多级页表的主要目的是为了<strong>避免把全部页表一直放在内存中占用过多空间</strong>，特别是那些根本就不需要的页表就不需要保留在内存中。</p><h2 id="4-分页机制和分段机制的共同点和区别"><a href="#4-分页机制和分段机制的共同点和区别" class="headerlink" title="4. 分页机制和分段机制的共同点和区别"></a>4. 分页机制和分段机制的共同点和区别</h2><p><strong>共同点</strong> ：<br>分页机制和分段机制都是为了<strong>提高内存利用率，减少内存碎片</strong>。<br>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。<br><strong>区别</strong>：<br><strong>页的大小是固定的</strong>，由操作系统决定；而<strong>段的大小不固定</strong>，取决于我们当前运行的程序。<br>分页仅仅是为了<strong>满足操作系统内存管理的需求</strong>，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好<strong>满足用户的需求</strong>。</p><h2 id="5-逻辑-虚拟-地址和物理地址"><a href="#5-逻辑-虚拟-地址和物理地址" class="headerlink" title="5. 逻辑(虚拟)地址和物理地址"></a>5. 逻辑(虚拟)地址和物理地址</h2><p>比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，<strong>逻辑地址由操作系统决定</strong>。<strong>物理地址指的是真实物理内存中地址</strong>，更具体一点来说就是<strong>内存地址寄存器中的地址</strong>。物理地址是内存单元真正的地址。</p><h2 id="6-CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#6-CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="6. CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>6. CPU 寻址了解吗?为什么需要虚拟地址空间?</h2><p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存</strong>。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元</strong>（Memory Management Unit, MMU） 的硬件。<br><img src="https://img-blog.csdnimg.cn/b3532546543644d2a04f0883cd6ae217.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="虚拟寻址"><br><strong>为什么要有虚拟地址空间呢？</strong><br>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</p><p><strong>通过虚拟地址访问内存有以下优势：</strong></p><ol><li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li><li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li><li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li></ol><h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="1-什么是虚拟内存-Virtual-Memory"><a href="#1-什么是虚拟内存-Virtual-Memory" class="headerlink" title="1. 什么是虚拟内存(Virtual Memory)?"></a>1. 什么是虚拟内存(Virtual Memory)?</h2><p>很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。为什么可以这样呢？ 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉</strong>（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。</p><p><strong>虚拟内存</strong>是一种<strong>计算机系统内存管理技术</strong>，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间</strong>。</p><h2 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h2><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的局部性原理。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。<br>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。<br>局部性原理表现在以下两个方面：</p><ul><li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令<strong>可能再次执行</strong>；如果某数据被访问过，不久以后该数据可能<strong>再次被访问</strong>。产生时间局部性的典型原因，是由于在<strong>程序中存在着大量的循环操作</strong>。</li><li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即<strong>程序在一段时间内所访问的地址，可能集中在一定的范围之内</strong>，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ul><p><strong>时间局部性</strong>是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。<br><strong>空间局部性</strong>通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。<br>虚拟内存技术实际上就是建立了 “<strong>内存一外存</strong>”的两级存储器的结构，利用<strong>局部性原理</strong>实现髙速缓存。</p><h2 id="3-虚拟存储器"><a href="#3-虚拟存储器" class="headerlink" title="3. 虚拟存储器"></a>3. 虚拟存储器</h2><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。</p><ul><li>在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，<strong>计算机好像为用户提供了一个比实际内存大的多的存储器</strong>——<strong>虚拟存储器</strong>。</li></ul><p>实际上，我觉得虚拟内存同样是一种 <strong>时间换空间</strong> 的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。</p><h2 id="4-虚拟内存的技术实现"><a href="#4-虚拟内存的技术实现" class="headerlink" title="4. 虚拟内存的技术实现"></a>4. 虚拟内存的技术实现</h2><p>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p><ol><li><strong>请求分页</strong>存储管理</li><li><strong>请求分段</strong>存储管理</li><li><strong>请求段页式</strong>存储管理</li></ol><p><strong>请求分页与分页存储管理，两者有何不同呢？</strong></p><p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。<br>它们之间的根本区别在于<strong>是否将一作业的全部地址空间同时装入主存</strong>。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，<strong>请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存</strong>。</p><h2 id="5-页面置换算法-页面置换算法的作用-常见的页面置换算法有哪些"><a href="#5-页面置换算法-页面置换算法的作用-常见的页面置换算法有哪些" class="headerlink" title="5. 页面置换算法(页面置换算法的作用?常见的页面置换算法有哪些?)"></a>5. 页面置换算法(页面置换算法的作用?常见的页面置换算法有哪些?)</h2><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生<strong>缺页中断</strong> 。<br><strong>缺页中断</strong>：就是要访问的页不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p><ul><li>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存<strong>选择一个页面将其移出内存</strong>，以便为即将调入的页面让出空间。<br><strong>用来选择淘汰哪一页的规则</strong>叫做<strong>页面置换算法</strong>，我们可以把页面置换算法看成是淘汰页面的规则。<br>（最佳、先进先出、最近最久未使用、最少使用）4种。</li></ul><ol><li>OPT 页面置换算法（<strong>最佳</strong>页面置换算法） ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li><li>FIFO（First In First Out） 页面置换算法（<strong>先进先出</strong>页面置换算法） : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li><li>LRU （Least Recently Used）页面置换算法（<strong>最近最久未使用</strong>页面置换算法） ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li><li>LFU （Least Frequently Used）页面置换算法（<strong>最少使用</strong>页面置换算法） : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li></ol><h1 id="后端程序员必备的-Linux-基础知识总结"><a href="#后端程序员必备的-Linux-基础知识总结" class="headerlink" title="后端程序员必备的 Linux 基础知识总结"></a>后端程序员必备的 Linux 基础知识总结</h1><h2 id="1-从认识操作系统开始"><a href="#1-从认识操作系统开始" class="headerlink" title="1. 从认识操作系统开始"></a>1. 从认识操作系统开始</h2><ol><li>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</li><li>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li><li>操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。<br><img src="https://img-blog.csdnimg.cn/d82b9f4c22c24229b7df7a3125dc2bd2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="os"><h2 id="2-操作系统简单分类"><a href="#2-操作系统简单分类" class="headerlink" title="2. 操作系统简单分类"></a>2. 操作系统简单分类</h2></li><li>Windows</li><li>Unix<br>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。<br>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</li><li>Linux<br><code>Linux</code> 是一套免费使用、开源的类 <code>Unix</code> 操作系统。 <code>Linux</code> 存在着许多不同的发行版本，但它们都使用了 <code>Linux</code> 内核 。<br>严格来讲，<code>Linux</code> 这个词本身只表示 <code>Linux</code> 内核，在 <code>GNU/Linux</code> 系统中，<code>Linux</code> 实际就是 <code>Linux</code> 内核，而该系统的其余部分主要是由 <code>GNU</code> 工程编写和提供的程序组成。单独的 <code>Linux</code> 内核并不能成为一个可以正常工作的操作系统。<br>很多人更倾向使用 “<code>GNU/Linux</code>” 一词来表达人们通常所说的 “<code>Linux</code>”。</li><li>Mac OS<br>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。<h2 id="3-操作系统的内核（Kernel）"><a href="#3-操作系统的内核（Kernel）" class="headerlink" title="3. 操作系统的内核（Kernel）"></a>3. 操作系统的内核（Kernel）</h2></li><li>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</li><li>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。<h2 id="4-中央处理器（CPU，Central-Processing-Unit）"><a href="#4-中央处理器（CPU，Central-Processing-Unit）" class="headerlink" title="4. 中央处理器（CPU，Central Processing Unit）"></a>4. 中央处理器（CPU，Central Processing Unit）</h2></li><li>CPU 是一台计算机的<strong>运算核心（Core）</strong>+<strong>控制核心（ Control Unit）</strong>，可以称得上是计算机的大脑。</li><li>CPU 主要包括两个部分：<strong>控制器</strong> + <strong>运算器</strong>。</li><li>CPU 的根本任务就是<strong>执行指令</strong>，对计算机来说最终都是一串由“0”和“1”组成的序列。<h2 id="5-CPU-vs-Kernel-内核"><a href="#5-CPU-vs-Kernel-内核" class="headerlink" title="5. CPU vs Kernel(内核)"></a>5. CPU vs Kernel(内核)</h2></li><li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li><li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。<h2 id="6-系统调用"><a href="#6-系统调用" class="headerlink" title="6. 系统调用"></a>6. 系统调用</h2>我们运行的用户程序中<strong>（用户态）</strong>，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成<strong>（系统态）</strong>。</li></ol><h1 id="2-初探-Linux"><a href="#2-初探-Linux" class="headerlink" title="2. 初探 Linux"></a>2. 初探 Linux</h1><h2 id="1-Linux-简介"><a href="#1-Linux-简介" class="headerlink" title="1. Linux 简介"></a>1. Linux 简介</h2><ul><li>类 <code>Unix</code> 系统 ： <code>Linux</code> 是一种自由、开放源码的类似 Unix 的操作系统</li><li><code>Linux</code> 本质是指 <code>Linux</code> 内核 ： 严格来讲，<code>Linux</code> 这个词本身只表示 <code>Linux</code> 内核，单独的 <code>Linux</code> 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 <code>Linux</code> 发行版。</li><li><code>Linux</code> 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds) ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <code>Linux</code> 内核 的最早作者，随后发起了这个开源项目，担任 <code>Linux</code> 内核的首要架构师。他还发起了 <code>Git</code> 这个开源项目，并为主要的开发者。<h2 id="2-常见-Linux-发行版本有哪些？"><a href="#2-常见-Linux-发行版本有哪些？" class="headerlink" title="2. 常见 Linux 发行版本有哪些？"></a>2. 常见 Linux 发行版本有哪些？</h2><code>Linux</code> 的发行版本可以大体分为两类：<br>商业公司维护的发行版本，以著名的 <code>Red Hat</code> 为代表，比较典型的有 <code>CentOS</code> 。<br>社区组织维护的发行版本，以 <code>Debian</code> 为代表，比较典型的有 <code>Ubuntu、</code>Debian<code>。 对于初学者学习 </code>Linux<code>,推荐选择</code>CentOS&#96; 。<h1 id="3-Linux-文件系统概览"><a href="#3-Linux-文件系统概览" class="headerlink" title="3. Linux 文件系统概览"></a>3. Linux 文件系统概览</h1><h2 id="1-Linux-文件系统简介"><a href="#1-Linux-文件系统简介" class="headerlink" title="1. Linux 文件系统简介"></a>1. Linux 文件系统简介</h2><strong>在 <code>Linux</code> 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件</strong>。(一切都是文件)。<h2 id="2-inode-index-node-介绍"><a href="#2-inode-index-node-介绍" class="headerlink" title="2. inode (index + node) 介绍"></a>2. inode (index + node) 介绍</h2><code>inode</code> 是 <code>linux/unix</code> 文件系统的基础。那么，<code>inode</code> 是什么?有什么作用呢?</li><li>inode ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li><li>block ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）<br><img src="https://img-blog.csdnimg.cn/abd1655d34c942eebe3116503647c86d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="inode"><h2 id="3-Linux-文件类型"><a href="#3-Linux-文件类型" class="headerlink" title="3. Linux 文件类型"></a>3. Linux 文件类型</h2><code>Linux</code> 支持很多文件类型，其中非常重要的文件类型有:<br>普通文件，目录文件，链接文件，设备文件，管道文件，Socket 套接字文件等。</li><li><strong>普通文件</strong>（-） ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li><li><strong>目录文件</strong>（d，directory file） ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li><li><strong>符号链接文件</strong>（l，symbolic link） ：保留了指向文件的地址而不是文件本身。</li><li><strong>字符设备</strong>（c，char） ：用来访问字符设备比如键盘。</li><li><strong>设备文件</strong>（b，block） ： 用来访问块设备比如硬盘、软盘。</li><li><strong>管道文件</strong>(p,pipe) : 一种特殊类型的文件，用于进程之间的通信。</li><li><strong>套接字</strong>(s,socket) ：用于进程间的网络通信，也可以用于本机之间的非网络通信。<h2 id="4-Linux-目录树"><a href="#4-Linux-目录树" class="headerlink" title="4. Linux 目录树"></a>4. Linux 目录树</h2><img src="https://img-blog.csdnimg.cn/d42ce99ada964bdca6f5fd9c0743e118.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="目录树"></li><li><strong>&#x2F;bin</strong>： 存放<strong>二进制可执行文件</strong>(ls、cat、mkdir 等)，<strong>常用命令</strong>一般都在这里；</li><li><strong>&#x2F;etc</strong>： 存放<strong>系统管理和配置文件</strong>；</li><li><strong>&#x2F;home</strong>： 存放所有用户文件的<strong>根目录</strong>，是用户主目录的基点，比如用户 user 的主目录就是&#x2F;home&#x2F;user，可以用~user 表示；</li><li><strong>&#x2F;usr</strong> ： 用于存放<strong>系统应用程序</strong>；</li><li><strong>&#x2F;opt</strong>： <strong>额外安装的可选应用程序包所放置的位置</strong>。一般情况下，我们可以把 <code>tomcat</code> 等都安装到这里；</li><li><strong>&#x2F;proc</strong>： <strong>虚拟文件系统目录</strong>，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>&#x2F;root</strong>： 超级用户（系统管理员）的<strong>主目录</strong>（特权阶级o）；</li><li><strong>&#x2F;sbin</strong>: 存放<strong>二进制可执行文件</strong>，只有 root 才能访问。这里存放的是系统管理员使用的<strong>系统级别</strong>的管理命令和程序。如 ifconfig 等；</li><li><strong>&#x2F;dev</strong>： 用于存放<strong>设备文件</strong>；</li><li><strong>&#x2F;mnt</strong>： 系统管理员安装<strong>临时文件系统的安装点</strong>，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>&#x2F;boot</strong>： 存放用于<strong>系统引导</strong>时使用的各种文件；</li><li><strong>&#x2F;lib</strong> ： 存放着和系统运行相关的<strong>库文件</strong> ；</li><li><strong>&#x2F;tmp</strong>： 用于存放各种<strong>临时文件</strong>，是公用的临时文件存储点；</li><li><strong>&#x2F;var</strong>： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的<strong>日志文件</strong>（系统启动日志等。）等；</li><li><strong>&#x2F;lost+found</strong>： 这个目录平时是空的，系统非正常关机而留下“<strong>无家可归</strong>”的文件（windows 下叫什么.chk）就在这里。<h1 id="4-Linux-基本命令"><a href="#4-Linux-基本命令" class="headerlink" title="4. Linux 基本命令"></a>4. Linux 基本命令</h1>Linux 命令大全：<a href="http://man.linuxde.net/">http://man.linuxde.net/</a><h2 id="1-目录切换命令"><a href="#1-目录切换命令" class="headerlink" title="1. 目录切换命令"></a>1. 目录切换命令</h2></li><li><code>cd usr</code>： 切换到该目录下 usr 目录</li><li><code>cd ..</code>（或<code>cd../</code>）： 切换到上一层目录</li><li><code>cd /</code>： 切换到系统根目录</li><li><code>cd ~</code>： 切换到用户主目录</li><li><code>cd -</code>： 切换到上一个操作所在目录<h2 id="2-目录的操作命令-增删改查"><a href="#2-目录的操作命令-增删改查" class="headerlink" title="2. 目录的操作命令(增删改查)"></a>2. 目录的操作命令(增删改查)</h2></li><li><code>mkdir</code> 目录名称：<strong>增加目录</strong>。</li><li><code>ls/ll</code>：<strong>查看目录</strong>信息</li><li><code>find</code> 目录 参数：<strong>寻找目录</strong>（查）。<code>find /home -name &quot;*.txt&quot;</code></li><li><code>mv</code> 目录名称 新目录名称：<strong>修改目录</strong>的名称（改）。</li><li><code>mv</code> 目录名称 目录的新位置：<strong>移动目录</strong>的位置—剪切（改）。</li><li><code>cp -r</code> 目录名称 目录拷贝的目标位置： <strong>拷贝目录</strong>（改），<code>-r</code> 代表递归拷贝 。</li><li><code>rm [-rf]</code> 目录 : <strong>删除目录</strong>（删）。<h2 id="3-文件的操作命令-增删改查"><a href="#3-文件的操作命令-增删改查" class="headerlink" title="3. 文件的操作命令(增删改查)"></a>3. 文件的操作命令(增删改查)</h2></li><li><code>touch</code> 文件名称: 文件的创建（增）。</li><li><code>cat/more/less/tail</code> 文件名称 ：文件的查看（查） 。<br>(命令 <code>tail -f</code> 文件 可以对某个文件进行动态监控，例如 <code>tomcat</code> 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。)</li><li><code>vim</code> 文件： 修改文件的内容（改）。<br>(<code>vim</code> 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：<code>wq/q!</code> （输入 <code>wq</code> 代表写入内容并退出，即保存；输入 <code>q!</code> 代表强制退出不保存）。)</li><li><code>rm -rf</code> 文件： 删除文件（删）。<h2 id="4-压缩文件的操作命令"><a href="#4-压缩文件的操作命令" class="headerlink" title="4. 压缩文件的操作命令"></a>4. 压缩文件的操作命令</h2></li></ul><p>1）打包并压缩文件：</p><ul><li><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>：其中：<br>z：调用 gzip 压缩命令进行压缩<br>c：打包文件<br>v：显示运行过程<br>f：指定文件名<br>（<code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code>）</li></ul><p>2）解压压缩包：</p><ul><li><code>tar [-xvf] 压缩文件</code>：其中：x：代表解压<br>将 &#x2F;test 下的 test.tar.gz 解压到当前目录下可以使用命令：<code>tar -xvf test.tar.gz</code><br>将 &#x2F;test 下的 test.tar.gz 解压到根目录&#x2F;usr 下：<code>tar -xvf test.tar.gz -C /usr</code>（- C 代表指定解压的位置）<h1 id="5-Linux-的权限命令"><a href="#5-Linux-的权限命令" class="headerlink" title="5. Linux 的权限命令"></a>5. Linux 的权限命令</h1>读(readable)、写(writable)和执行(excutable)<br><img src="https://img-blog.csdnimg.cn/50169f139bee48869794f45ef421cebd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="rwx"><br><img src="https://img-blog.csdnimg.cn/6e4db7ca44f24a45b112d38004bfe011.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_11,color_FFFFFF,t_70,g_se,x_16" alt="rwx"><br><strong>文件的类型：</strong></li><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是 window 中的快捷方式）<br><strong>Linux 中权限分为以下几种：</strong></li><li>r：代表权限是可读，r 也可以用数字 4 表示</li><li>w：代表权限是可写，w 也可以用数字 2 表示</li><li>x：代表权限是可执行，x 也可以用数字 1 表示<br><strong>文件和目录权限的区别：</strong></li></ul><p><strong>对于文件：</strong></p><table><thead><tr><th align="center">权限名称</th><th align="center">可执行操作</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">可以使用 cat 查看文件的内容</td></tr><tr><td align="center">w</td><td align="center">可以修改文件的内容</td></tr><tr><td align="center">x</td><td align="center">可以将其运行为二进制文件</td></tr></tbody></table><p><strong>对于目录：</strong></p><table><thead><tr><th align="center">权限名称</th><th align="center">可执行操作</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">可以查看目录下列表</td></tr><tr><td align="center">w</td><td align="center">可以创建和删除目录下文件</td></tr><tr><td align="center">x</td><td align="center">可以使用 cd 进入目录</td></tr></tbody></table><p><strong>修改文件&#x2F;目录的权限的命令：<code>chmod</code></strong><br><code>chmod u=rwx,g=rw,o=r aaa.txt</code> 或者 <code>chmod 764 aaa.txt</code><br><img src="https://img-blog.csdnimg.cn/3049319da5a7497994e9aa7720d80f89.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_12,color_FFFFFF,t_70,g_se,x_16" alt="chmod"><br><strong>补充比较常用</strong><br>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本 <code>zookeeper</code></li><li>为新建的脚本 <code>zookeeper</code> 添加可执行权限，命令是: <code>chmod +x zookeeper</code></li><li>把 <code>zookeeper</code> 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li><li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code><h1 id="6-Linux-用户管理"><a href="#6-Linux-用户管理" class="headerlink" title="6. Linux 用户管理"></a>6. Linux 用户管理</h1><code>Linux</code> 用户管理相关命令:</li></ol><p><code>useradd</code> 选项 用户名：添加用户账号<br><code>userdel</code> 选项 用户名：删除用户帐号<br><code>usermod</code> 选项 用户名：修改帐号<br><code>passwd</code> 用户名：更改或创建用户的密码<br><code>passwd -S</code> 用户名：显示用户账号密码信息<br><code>passwd -d</code> 用户名：清除用户密码</p><h1 id="7-Linux-系统用户组的管理"><a href="#7-Linux-系统用户组的管理" class="headerlink" title="7. Linux 系统用户组的管理"></a>7. Linux 系统用户组的管理</h1><p><code>Linux</code> 系统用户组的管理相关命令：<br><code>groupadd</code> 选项 用户组：增加一个新的用户组<br><code>groupdel</code> 用户组：要删除一个已有的用户组<br><code>groupmod</code> 选项 用户组：修改用户组的属性</p><h1 id="8-其他常用命令"><a href="#8-其他常用命令" class="headerlink" title="8. 其他常用命令"></a>8. 其他常用命令</h1><ul><li><p><code>pwd</code>： 显示当前所在位置</p></li><li><p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 <code>sudo</code> 所执行的指令就好像是 <code>root</code> 亲自执行。</p></li><li><p><code>grep</code> 要搜索的字符串 要搜索的文件 <code>--color</code>：搜索命令，<code>--color</code> 代表高亮显示</p></li><li><p><code>ps -ef/ps -aux</code>： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<code>ps aux|grep redis</code> （查看包括 <code>redis</code> 字符串的进程），也可使用 <code>pgrep redis -a</code>。<br>注意：如果直接用 <code>ps</code>（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p></li><li><p><code>kill -9</code> 进程的pid： 杀死进程（<code>-9</code> 表示强制终止。）<br>先用 <code>ps</code> 查找进程，然后用 <code>kill</code> 杀掉</p></li><li><p><strong>网络通信命令：</strong></p><ul><li>查看当前系统的网卡信息：<code>ifconfig</code></li><li>查看与某台机器的连接情况：<code>ping</code></li><li>查看当前系统的端口使用：<code>netstat -an</code></li><li><code>net-tools</code> 和 <code>iproute2</code>：配置网络功能的工具</li><li><code>shutdown</code>：<code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5</code> “System will shutdown after 5 minutes”：指定 5 分钟后关机，同时送出警告信息给登入用户。</li><li><code>reboot</code>：<code>reboot</code>： 重开机。<code>reboot -w</code>： 做个重开机的模拟（只有纪录并不会真的重开机）。<h1 id="Shell-编程入门"><a href="#Shell-编程入门" class="headerlink" title="Shell 编程入门"></a>Shell 编程入门</h1><code>Shell</code> 是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。<br>Shell编程就是对一堆Linux命令的逻辑化处理<br>(1) 新建一个文件 <code>helloworld.sh :touch helloworld.sh</code>，扩展名为 <code>sh</code>（<code>sh</code> 代表 <code>Shell</code> ）（扩展名并不影响脚本执行，见名知意就好，如果你用 <code>php</code> 写 <code>shell</code> 脚本，扩展名就用 <code>php</code> 好了）<br>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code><br>(3) 使用 <code>vim</code> 命令修改 <code>helloworld.sh</code> 文件：<code>vim helloworld.sh</code> (vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：<code>wq/q!</code> （输入 <code>wq</code> 代表写入内容并退出，即保存；输入 <code>q!</code> 代表强制退出不保存。）)<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#!开始来指定使用的 shell 类型</span></span><br><span class="line"><span class="comment">#第一个shell小程序,echo 是linux中的输出命令。</span></span><br><span class="line"><span class="built_in">echo</span>  <span class="string">&quot;helloworld!&quot;</span></span><br></pre></td></tr></table></figure>(4) 运行脚本：<code>./helloworld.sh</code> 。</li></ul></li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a></p><p><img src="https://img-blog.csdnimg.cn/4343a2825df947a3bd6ef4e4df66720f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="公主"></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java容器、并发编程、JVM</title>
      <link href="/2022/02/27/Java%E5%AE%B9%E5%99%A8%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81JVM/"/>
      <url>/2022/02/27/Java%E5%AE%B9%E5%99%A8%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81JVM/</url>
      
        <content type="html"><![CDATA[<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="1-Java-集合概览"><a href="#1-Java-集合概览" class="headerlink" title="1. Java 集合概览"></a>1. Java 集合概览</h2><p>Java <strong>集合</strong>， 也叫作<strong>容器</strong>，主要是由<strong>两大接口</strong>：<br><code>Collection</code> 接口：存放<strong>单一元素</strong>；（三个子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。）<br><code>Map</code> 接口：存放<strong>键值对</strong>。<br><img src="https://img-blog.csdnimg.cn/96963fb73ed54e699fd6e747fb1db77b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="集合"></p><h2 id="2-List-Set-Queue-Map-四者的区别？"><a href="#2-List-Set-Queue-Map-四者的区别？" class="headerlink" title="2. List, Set, Queue, Map 四者的区别？"></a>2. List, Set, Queue, Map 四者的区别？</h2><p><code>List</code>：存储的元素是<strong>有序</strong>的、<strong>可重复</strong>的。<br><code>Set</code>：存储的元素是<strong>无序</strong>的、<strong>不可重复</strong>的。<br><code>Queue</code>：按特定的排队规则来确定先后顺序（<strong>链式存储</strong>），存储的元素是<strong>有序的</strong>、<strong>可重复</strong>的。<br><code>Map</code>：使用<strong>键值对</strong>（key-value）存储，类似于数学上的函数 y&#x3D;f(x)，”x” 代表 key，”y” 代表 value，<strong>key</strong> 是<strong>无序的、不可重复</strong>的，<strong>value</strong> 是<strong>无序的、可重复</strong>的，每个键最多映射到一个值。</p><h2 id="3-集合框架底层数据结构总结"><a href="#3-集合框架底层数据结构总结" class="headerlink" title="3. 集合框架底层数据结构总结"></a>3. 集合框架底层数据结构总结</h2><p>先来看一下 Collection 接口下面的集合。</p><ol><li><p><code>List</code><br><code>Arraylist</code>： <code>Object[]</code> 数组<br><code>Vector</code>：<code>Object[]</code> 数组<br><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p></li><li><p><code>Set</code><br><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素<br><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的<br><code>TreeSet</code>(有序，唯一): 红黑树（自平衡的排序二叉树）</p></li><li><p><code>Queue</code><br><code>PriorityQueue</code>：<code>Object[]</code> 数组来实现二叉堆<br><code>ArrayQueue</code>：<code>Object[]</code> 数组 + 双指针</p></li><li><p><code>Map</code><br><code>HashMap</code>：由<strong>数组</strong> + <strong>双链表</strong>组成，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）JDK1.8 以后当链表长度大于阈值（默认为 8）时，将<strong>链表转化为红黑树</strong>，以<strong>减少搜索时间</strong>。<br><code>LinkedHashMap</code>：由<strong>数组</strong> + <strong>双链表&#x2F;红黑树</strong>组成，继承自 <code>HashMap</code>，底层仍然是基于<strong>拉链式散列结构</strong>即由数组和链表或红黑树组成。区别在于增加了一条双向链表（链操作），使得上面的结构可以保持键值对的插入顺序。<br><code>Hashtable</code>： <strong>数组</strong>（主体）+ <strong>单链表</strong>（解决哈希冲突）组成。<br><code>TreeMap</code>：红黑树（自平衡的排序二叉树）</p><h2 id="4-如何选用集合"><a href="#4-如何选用集合" class="headerlink" title="4. 如何选用集合?"></a>4. 如何选用集合?</h2></li><li><p>根据键值获取到元素值时：<code>Map</code><br><code>TreeMap</code>：需要排序时<br><code>HashMap</code>：不需要排序时<br><code>ConcurrentHashMap</code>：线程安全</p></li><li><p>只需要存放元素值时：<code>Collection</code><br><code>TreeSet</code> 或 <code>HashSet</code>：保证元素唯一   <code>Set</code><br><code>ArrayList</code> 或 <code>LinkedList</code>：不需要保证唯一  <code>List</code></p><h2 id="5-为什么要使用集合？"><a href="#5-为什么要使用集合？" class="headerlink" title="5. 为什么要使用集合？"></a>5. 为什么要使用集合？</h2><p>保存一组类型相同的数据时，需用一个容器保存，这个容器就是数组，但是实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。<br><strong>数组的缺点</strong>：① 一旦声明之后，<strong>长度不可变</strong>；② 声明数组时的<strong>数据类型</strong>也决定了该数组存储的数据的类型；③ 数组存储的数据是<strong>有序的、可重复</strong>的，特点<strong>单一</strong>。<br>集合提高了数据存储的灵活性，Java 集合不仅可以用来 <strong>① 存储不同类型不同数量的对象</strong>，还可以保 <strong>② 存具有映射关系</strong>的数据。</p><h1 id="Collection-子接口之-List"><a href="#Collection-子接口之-List" class="headerlink" title="Collection 子接口之 List"></a>Collection 子接口之 List</h1><h2 id="1-Arraylist-和-Vector-的区别？"><a href="#1-Arraylist-和-Vector-的区别？" class="headerlink" title="1. Arraylist 和 Vector 的区别？"></a>1. Arraylist 和 Vector 的区别？</h2><p>底层使用 <strong><code>Object[ ]</code></strong> 数组 存储<br><code>ArrayList</code> (主要实现类)：适用于<strong>频繁查找</strong>工作，<strong>线程不安全</strong>；<br><code>Vector</code> ：<strong>线程安全</strong>。</p><h2 id="2-Arraylist-与-LinkedList-区别？"><a href="#2-Arraylist-与-LinkedList-区别？" class="headerlink" title="2. Arraylist 与 LinkedList 区别？"></a>2. Arraylist 与 LinkedList 区别？</h2></li><li><p>是否保证<strong>线程安全</strong>：都是不同步（不保证线程安全）</p></li><li><p><strong>底层数据结构</strong>：<code>Arraylist</code> 底层是 <code>Object[ ]</code>， <code>LinkedList</code> 底层是 <code>Object[ ]</code> 和 <strong>双向链表</strong>。</p></li><li><p><strong>插入和删除是否受元素位置的影响</strong>：<br><code>Arraylist</code>：采用数组存储，顺序存储。元素追加到列表末尾O(1)，插入或删除O(n-i)<br><code>LinkedList</code>：采用链表存储，链式存储。在头尾插入或者删除元素O(1)，指定位置O(n)。</p></li><li><p>快速<strong>随机访问</strong>：顺序存储支持（索引），链式不支持（遍历）。</p></li><li><p><strong>内存空间</strong>占用：<code>Arraylist</code> 列表的结尾会预留一定的容量空间（数组，磁盘碎片）。<code>LinkedList</code> 占用更大（存放前驱后继及数据）</p><h2 id="3-ArrayList-的扩容机制"><a href="#3-ArrayList-的扩容机制" class="headerlink" title="3. ArrayList 的扩容机制"></a>3. ArrayList 的扩容机制</h2></li></ol><ul><li>以无参数构造方法创建 <code>ArrayList</code> 时，<strong>实际上初始化赋值的是一个空数组</strong>。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</li><li>添加第2、3···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li><li>直到<strong>添加第 11 个元素</strong>，<code>minCapacity</code>(为 11)比 <code>elementData.length</code>（为 10）要大。进入 grow 方法进行扩容。<h1 id="Collection-子接口之-Set"><a href="#Collection-子接口之-Set" class="headerlink" title="Collection 子接口之 Set"></a>Collection 子接口之 Set</h1><h2 id="1-comparable-和-Comparator-的区别？"><a href="#1-comparable-和-Comparator-的区别？" class="headerlink" title="1. comparable 和 Comparator 的区别？"></a>1. comparable 和 Comparator 的区别？</h2><code>comparable</code> 接口（java.lang）：<code>compareTo(Object obj)</code> 方法排序<br><code>comparator</code> 接口（java.util）：<code>compare(Object obj1, Object obj2)</code> 方法排序<br>一般我们需要对一个集合使用自定义排序时，我们就要重写 <code>compareTo()</code> 方法或 <code>compare()</code> 方法<h2 id="2-无序性和不可重复性的含义是什么？"><a href="#2-无序性和不可重复性的含义是什么？" class="headerlink" title="2. 无序性和不可重复性的含义是什么？"></a>2. 无序性和不可重复性的含义是什么？</h2></li><li><strong>无序性</strong>：指存储的数据在底层数组中<strong>并非</strong>按照数组 <strong>索引</strong> 的顺序添加 ，而是根据数据的 <strong>哈希值</strong> 决定的。</li><li><strong>不可重复性</strong>：指添加的元素按照 <code>equals()</code> 判断时 ，返回 <code>false</code>（需要同时重写 <code>equals()</code> 方法和 <code>HashCode()</code>方法）<h2 id="3-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#3-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="3. HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>3. HashSet、LinkedHashSet 和 TreeSet 三者的异同</h2> <strong>同</strong>：① 都是 <code>Set</code> 接口的实现类，② 都能保证元素唯一，并且③ 都不是线程安全的。<br><strong>异</strong>：① 底层数据结构不同。</li><li><code>HashSet</code>：<strong>哈希表</strong>（基于 HashMap 实现）</li><li><code>LinkedHashSet</code>：<strong>哈希表</strong> 和 <strong>双向链表</strong>（FIFO）。</li><li><code>TreeSet</code>：<strong>哈希表</strong> 和 <strong>红黑树</strong>。元素是有序的，排序的方式有自然排序和定制排序。<br>② 底层数据结构不同又导致这三者的应用场景不同。</li><li><code>HashSet</code>：<strong>不需要保证</strong>元素插入和取出<strong>顺序场景</strong>。</li><li><code>LinkedHashSet</code>：<strong>保证</strong>元素的插入和取出顺序满足FIFO。</li><li><code>TreeSet</code>：支持对元素<strong>自定义排序</strong>规则。<h1 id="Collection-子接口之-Queue"><a href="#Collection-子接口之-Queue" class="headerlink" title="Collection 子接口之 Queue"></a>Collection 子接口之 Queue</h1><h2 id="1-Queue-与-Deque-的区别"><a href="#1-Queue-与-Deque-的区别" class="headerlink" title="1. Queue 与 Deque 的区别"></a>1. <code>Queue</code> 与 <code>Deque</code> 的区别</h2><code>Queue</code>：单端队列，单端插入或删除元素，先进先出（FIFO）<br><code>Deque</code>：双端队列，双端插入或删除元素。<h2 id="2-ArrayDeque-与-LinkedList-的区别"><a href="#2-ArrayDeque-与-LinkedList-的区别" class="headerlink" title="2. ArrayDeque 与 LinkedList 的区别"></a>2. ArrayDeque 与 LinkedList 的区别</h2><strong>同</strong>：都实现了 <code>Deque</code> 接口，两者都具有队列的功能<br><strong>异</strong>：</li><li><code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><code>ArrayDeque</code> 不支持存储 NULL 数据，但 <code>LinkedList</code> 支持。</li><li><code>ArrayDeque</code> 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 <code>LinkedList</code> 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。</li><li><code>ArrayDeque</code> 来实现队列要比 <code>LinkedList</code> 性能更好。还能实现栈。<h2 id="3-PriorityQueue"><a href="#3-PriorityQueue" class="headerlink" title="3. PriorityQueue"></a>3. PriorityQueue</h2>JDK1.5 中引入, 其与 Queue 的区别在于元素<strong>出队顺序是与优先级相关</strong>，即总是优先级最高的元素先出队。</li><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用可变长的数组来存储数据。</li><li><code>PriorityQueue</code> 通过<strong>堆元素的上浮和下沉</strong>，实现了在 <code>O(logn)</code> 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是<strong>非线程安全</strong>的，且不支持存储 NULL 和 non-comparable 的对象。</li><li><code>PriorityQueue</code> 默认是<strong>小顶堆</strong>，但可以接收一个 <code>Comparator</code> 作为<strong>构造参数</strong>，从而来自定义元素优先级的先后。<h1 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h1><h2 id="1-HashMap-和-Hashtable-的区别"><a href="#1-HashMap-和-Hashtable-的区别" class="headerlink" title="1. HashMap 和 Hashtable 的区别"></a>1. HashMap 和 Hashtable 的区别</h2></li></ul><ol><li><strong>线程是否安全</strong>： <code>HashMap</code> 是<strong>非线程安全</strong>的，<code>Hashtable</code> 是<strong>线程安全</strong>的（内部的方法基本都经过<code>synchronized</code> 修饰）。（如果你要保证线程安全的话就使用 <code>ConcurrentHashMap</code> 吧！）；</li><li><strong>效率</strong>：<code>HashMap</code> （<strong>线程非安全</strong>）要比 <code>Hashtable</code> （基本淘汰）效率高一点。</li><li><strong>对 Null key 和 Null value 的支持</strong>： <code>HashMap</code> 可以存储 <code>null</code> 的 <code>key</code> (1个)和 <code>value</code> (多个)</li><li><strong>初始容量</strong>大小和每次<strong>扩充容量</strong>大小的不同：<code>HashMap</code> 会将其扩充为 2 的幂次方大小，<code>Hashtable</code> 扩充 2n+1。</li><li><strong>底层数据结构</strong>：<code>HashMap</code> 在解决哈希冲突时当链表长度大于阈值（默认为 8）时，将<strong>链表</strong>转化为<strong>红黑树</strong>，以减少搜索时间。<h2 id="2-HashMap-和-HashSet-区别"><a href="#2-HashMap-和-HashSet-区别" class="headerlink" title="2. HashMap 和 HashSet 区别"></a>2. HashMap 和 HashSet 区别</h2><code>HashSet</code> 底层基于 <code>HashMap</code> 实现。<table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现 <code>Map</code> 接口</td><td>实现 <code>Set</code> 接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用 <code>put()</code>向 <code>map</code> 中添加元素</td><td>调用 <code>add()</code>方法向 <code>Set</code> 中添加元素</td></tr><tr><td><code>HashMap</code> 使用键（Key）计算 <code>hashcode</code></td><td><code>HashSet</code> 使用成员对象来计算 <code>hashcode</code> 值，对于两个对象来说 <code>hashcode</code> 可能相同，所以<code>equals()</code>方法用来判断对象的相等性</td></tr></tbody></table><h2 id="3-HashMap-和-TreeMap-区别"><a href="#3-HashMap-和-TreeMap-区别" class="headerlink" title="3. HashMap 和 TreeMap 区别"></a>3. HashMap 和 TreeMap 区别</h2><code>TreeMap</code> 和 <code>HashMap</code> 都继承自 <code>AbstractMap</code> ，但是需要注意的是 <code>TreeMap</code> 它还实现了 <code>NavigableMap</code> 接口和<code>SortedMap</code> 接口。<br><code>NavigableMap</code> 接口：让 TreeMap 有了对集合内元素的<strong>搜索能力</strong>。<br><code>SortedMap</code> 接口：让 TreeMap 有了对集合中的元素根据<strong>键排序能力</strong>。<h2 id="4-HashSet-如何检查重复"><a href="#4-HashSet-如何检查重复" class="headerlink" title="4. HashSet 如何检查重复"></a>4. HashSet 如何检查重复</h2>对象加入<code>HashSet</code> 时，<code>HashSet</code> 会先计算<strong>对象的 <code>hashcode</code> 值</strong>来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较.</li></ol><ul><li>如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。</li><li>如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code> 方法来检查 <code>hashcode</code> 相等的对象是否真的相同。</li><li>如果两者相同，<code>HashSet</code> 就不会让加入操作成功。<h2 id="5-HashMap-的底层实现"><a href="#5-HashMap-的底层实现" class="headerlink" title="5. HashMap 的底层实现"></a>5. HashMap 的底层实现</h2>JDK1.8 之前 HashMap 底层：数组和<strong>链表</strong>（链表散列）（哈希冲突用拉链法。）<br>JDK1.8 之后 HashMap 底层：数组和<strong>链表&#x2F;红黑树</strong>（当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。）<h2 id="6-HashMap-的长度为什么是-2-的幂次方？"><a href="#6-HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="6. HashMap 的长度为什么是 2 的幂次方？"></a>6. HashMap 的长度为什么是 2 的幂次方？</h2>存放的位置（对应的数组下标，存放松散防冲突）计算方法是：<code> hash &amp; (n - 1)</code><br><code>hash%length==hash&amp;(length-1)</code>  前提是 <code>length = 2^n</code>。二进制位操作效率更好。<h2 id="7-HashMap-多线程操作导致死循环问题"><a href="#7-HashMap-多线程操作导致死循环问题" class="headerlink" title="7. HashMap 多线程操作导致死循环问题"></a>7. HashMap 多线程操作导致死循环问题</h2>并发下的 <code>Rehash</code> 会造成元素之间会形成一个循环链表。<br>多线程下使用 <code>HashMap</code> 还是会存在其他问题比如数据丢失。<br>（并发环境下推荐使用 <code>ConcurrentHashMap</code> ）。<h2 id="8-ConcurrentHashMap-和-Hashtable-的区别"><a href="#8-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="8. ConcurrentHashMap 和 Hashtable 的区别"></a>8. ConcurrentHashMap 和 Hashtable 的区别</h2>主要体现在：实现<strong>线程安全的方式</strong>上</li><li><strong>底层数据结构</strong>：JDK1.7 的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，<br>JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表&#x2F;红黑二叉树。</li><li><strong>实现线程安全的方式</strong>：<br>① 在 JDK1.7 的时候，**<code>ConcurrentHashMap</code>（分段锁）** 对整个数组进行了分割分段(<code>Segment</code>)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。到了 JDK1.8 的时候已经摒弃了 <code>Segment</code> 的概念，而是直接用 <strong>Node 数组+链表+红黑树</strong>的数据结构来实现，<strong>并发控制使用 <code>synchronized</code> 和 CAS 来操作</strong>。<br>② **Hashtable(同一把锁)**：使用 <code>synchronized</code> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 <code>put</code> 添加元素，另一个线程不能使用 <code>put</code> 添加元素，也不能使用 <code>get</code>，竞争会越来越激烈效率越低。<h2 id="9-Collections-工具类"><a href="#9-Collections-工具类" class="headerlink" title="9. Collections 工具类"></a>9. Collections 工具类</h2><code>Collections</code> 工具类常用方法：</li></ul><ol><li>排序<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(List list, <span class="type">int</span> i , <span class="type">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(List list, <span class="type">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></pre></td></tr></table></figure></li><li>查找,替换操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target)</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span><br></pre></td></tr></table></figure></li><li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)<br><code>Collections</code> 提供了多个 <code>synchronizedXxx()</code> 方法·，该方法可以将指定集合包装成<strong>线程同步的集合</strong>，从而解决多线程并发访问集合时的线程安全问题。<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="1-什么是进程和线程？"><a href="#1-什么是进程和线程？" class="headerlink" title="1.什么是进程和线程？"></a>1.什么是进程和线程？</h2></li></ol><ul><li><strong>进程</strong>：程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。<br>系统运行一个程序即是一个进程从创建，运行到消亡的过程。<br>main 函数时其实就是启动了一个 <strong>JVM 的进程</strong>，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</li><li><strong>线程</strong>：比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。<br><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</strong><h2 id="2-图解进程和线程的关系"><a href="#2-图解进程和线程的关系" class="headerlink" title="2. 图解进程和线程的关系"></a>2. 图解进程和线程的关系</h2><img src="https://img-blog.csdnimg.cn/45dc885022424d1fa0fed75edf2161ea.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>一个进程中可以有多个线程，<strong>多个线程共享进程的堆和方法区</strong> (JDK1.8 之后的元空间)资源，但是每个线程有自己的<strong>程序计数器、虚拟机栈 和 本地方法栈</strong>。<br><strong>总结</strong>： 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上<strong>各进程是独立的</strong>，而各线程则不一定，因为<strong>同一进程中的线程极有可能会相互影响</strong>。线程执行开销小（轻量级进程），但不利于资源的管理和保护；而进程正相反。<h2 id="3-程序计数器为什么是私有的"><a href="#3-程序计数器为什么是私有的" class="headerlink" title="3. 程序计数器为什么是私有的?"></a>3. 程序计数器为什么是私有的?</h2>程序计数器私有主要是为了：<strong>线程切换后能恢复到正确的执行位置</strong></li></ul><ol><li>字节码解释器通过改变程序计数器来<strong>依次读取指令</strong>，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>（如果执行的是 <code>native</code> 方法，那么程序计数器记录的是 <code>undefined</code> 地址。只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。）<h2 id="4-虚拟机栈和本地方法栈为什么是私有的"><a href="#4-虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="4. 虚拟机栈和本地方法栈为什么是私有的?"></a>4. 虚拟机栈和本地方法栈为什么是私有的?</h2><strong>保证线程中的局部变量不被别的线程访问到</strong>。</li></ol><ul><li><strong>虚拟机栈</strong>： 每个 Java 方法在执行的同时会创建一个栈帧用于存储<strong>局部变量表、操作数栈、常量池引用</strong>等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈</strong>： 和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈</strong>为虚拟机执行 <strong>Java 方法</strong> （也就是字节码）服务，而<strong>本地方法栈</strong>则为虚拟机使用到的 <strong><code>Native</code> 方法服务</strong>。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<h2 id="5-一句话简单了解堆和方法区"><a href="#5-一句话简单了解堆和方法区" class="headerlink" title="5. 一句话简单了解堆和方法区"></a>5. 一句话简单了解堆和方法区</h2>堆和方法区是所有线程共享的资源.</li><li><strong>堆</strong>是进程中最大的一块内存，主要用于<strong>存放新创建的对象</strong> (几乎所有对象都在这里分配内存).</li><li><strong>方法区</strong>主要用于存放<strong>已被加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。<h2 id="6-并发与并行的区别？"><a href="#6-并发与并行的区别？" class="headerlink" title="6. 并发与并行的区别？"></a>6. 并发与并行的区别？</h2></li><li><strong>并发</strong>：两个及两个以上的作业在 <strong>单位时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在 <strong>单位时间</strong> 执行。<h2 id="7-为什么要使用多线程呢"><a href="#7-为什么要使用多线程呢" class="headerlink" title="7. 为什么要使用多线程呢?"></a>7. 为什么要使用多线程呢?</h2></li><li><strong>计算机底层</strong>：线程是轻量级进程，线程间的<strong>切换和调度的成本</strong>远远小于进程。</li><li><strong>互联网发展</strong>（千万级的高并发量）：提高系统整体的<strong>并发能力</strong>以及性能</li><li><strong>单核时代</strong>：使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而<strong>提高了 Java 进程利用系统资源的整体效率</strong>。</li><li><strong>多核时代</strong>：提高进程利用多核 CPU 的能力。<h2 id="8-使用多线程可能带来什么问题？"><a href="#8-使用多线程可能带来什么问题？" class="headerlink" title="8. 使用多线程可能带来什么问题？"></a>8. 使用多线程可能带来什么问题？</h2>并发编程的目的就是为了能<strong>提高程序的执行效率</strong>提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：<strong>内存泄漏、死锁、线程不安全</strong>等等。<h2 id="9-说说线程的生命周期和状态？"><a href="#9-说说线程的生命周期和状态？" class="headerlink" title="9. 说说线程的生命周期和状态？"></a>9. 说说线程的生命周期和状态？</h2></li><li>线程创建之后它将处于 <strong>NEW（新建） 状态</strong>，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</li><li>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 <strong>TIMED_WAITING</strong> 状态。当超时时间到达后 Java 线程将会返回到 <strong>RUNNABLE 状态</strong>。当线程调用同步方法时，在<strong>没有获取到锁</strong>的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 <strong>Runnable</strong> 的 <code>run()</code> 方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。<h2 id="10-什么是上下文切换？"><a href="#10-什么是上下文切换？" class="headerlink" title="10. 什么是上下文切换？"></a>10. 什么是上下文切换？</h2><strong>上下文</strong>：线程在执行过程中会有自己的运行条件和状态（程序计数器，栈信息等）。<br>当出现如下情况的时候，线程会从占用 CPU 状态中退出：</li></ul><ol><li>主动让出 CPU，比如调用了 sleep(), wait() 等。</li><li>时间片用完，因为操作系统要防止一个线程或者进程长时间占用CPU导致其他线程或者进程饿死。</li><li>调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。</li><li>被终止或结束运行<br><strong>上下文切换</strong>：前三种都会发生<strong>线程切换</strong>，<strong>需要保存当前线程的上下文</strong>，留待线程下次占用 CPU 的时候<strong>恢复</strong>现场。（频繁切换就会造成整体效率低下）<h2 id="11-什么是线程死锁？如何避免死锁？"><a href="#11-什么是线程死锁？如何避免死锁？" class="headerlink" title="11. 什么是线程死锁？如何避免死锁？"></a>11. 什么是线程死锁？如何避免死锁？</h2><strong>线程死锁</strong>：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。（线程被无限期地阻塞，因此程序不可能正常终止）<br><img src="https://img-blog.csdnimg.cn/de3f739176be410f92f5e043c22be726.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_8,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>死锁的四个必要条件：</strong></li><li><strong>互斥</strong>条件：该资源任意一个时刻只由一个线程占用。（一次性申请所有的资源）</li><li><strong>请求与保持</strong>条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。（占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源）</li><li><strong>循环等待</strong>条件：若干线程之间形成一种头尾相接的循环等待资源关系。（靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。）</li></ol><p><strong>避免死锁</strong>：在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。</p><h2 id="12-说说-sleep-方法和-wait-方法区别和共同点"><a href="#12-说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="12. 说说 sleep() 方法和 wait() 方法区别和共同点?"></a>12. 说说 sleep() 方法和 wait() 方法区别和共同点?</h2><ul><li><strong>同</strong>：两者都可以暂停线程的执行。</li><li><strong>异</strong>：</li></ul><ol><li><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><code>wait()</code> 通常被用于<strong>线程间交互&#x2F;通信</strong>，<code>sleep()</code> 通常被用于<strong>暂停执行</strong>。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code> 或者 <code>notifyAll()</code> 方法。<code>sleep()</code> 方法执行完成后，线程会自动苏醒。或者可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。<h2 id="13-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？"><a href="#13-为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？" class="headerlink" title="13. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？"></a>13. 为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h2></li></ol><ul><li><code>new</code> 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code> 方法，会启动一个线程并使线程进入了<strong>就绪状态</strong>，当分配到<strong>时间片</strong>后就可以开始运行了。 <strong><code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run() </code>方法的内容</strong>，这是真正的多线程工作。</li><li>直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 <code>main</code> 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。<br><strong>总结</strong>：调用 <code>start()</code> 方法方可<strong>启动线程并使线程进入就绪状态</strong>，直接执行 <code>run()</code> 方法的话不会以多线程的方式执行。<h1 id="Java-并发常见知识点-amp-面试题总结（进阶篇）"><a href="#Java-并发常见知识点-amp-面试题总结（进阶篇）" class="headerlink" title="Java 并发常见知识点&amp;面试题总结（进阶篇）"></a>Java 并发常见知识点&amp;面试题总结（进阶篇）</h1><h2 id="1-synchronized-关键字"><a href="#1-synchronized-关键字" class="headerlink" title="1. synchronized 关键字"></a>1. synchronized 关键字</h2><strong>解决的是</strong>：多个线程之间访问资源的<strong>同步性</strong>。保证被它修饰的方法或者代码块在任意时刻<strong>只能有一个线程</strong>执行。<br>Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。<br>监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code>（互斥锁）来实现的，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，<strong>都需要操作系统帮忙完成</strong>，而操作系统实现<strong>线程之间的切换时需要从用户态转换到内核态</strong>，需要相对比较长的时间，时间成本相对较高。<br>JDK1.6 对锁的实现引入了大量的优化，如<strong>自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁</strong>等技术来<strong>减少锁操作的开销</strong>。<h2 id="2-说说自己是怎么使用-synchronized-关键字"><a href="#2-说说自己是怎么使用-synchronized-关键字" class="headerlink" title="2. 说说自己是怎么使用 synchronized 关键字"></a>2. 说说自己是怎么使用 synchronized 关键字</h2></li></ul><ol><li><code>synchronized</code> 关键字加到 <code>static</code> <strong>静态方法</strong>和<code> synchronized(class)</code> <strong>代码块</strong>上都是是给 <strong><code>Class</code> 类</strong>上锁。</li><li><code>synchronized</code> 关键字加到<strong>实例方法</strong>上是给<strong>对象实例</strong>上锁。（差别）</li><li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！<h2 id="3-构造方法可以使用-synchronized-关键字修饰么？"><a href="#3-构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="3. 构造方法可以使用 synchronized 关键字修饰么？"></a>3. 构造方法可以使用 synchronized 关键字修饰么？</h2>不能。<strong>构造方法</strong>本身就属于<strong>线程安全</strong>的，不存在同步的构造方法一说。<h2 id="4-讲一下-synchronized-关键字的底层原理"><a href="#4-讲一下-synchronized-关键字的底层原理" class="headerlink" title="4. 讲一下 synchronized 关键字的底层原理"></a>4. 讲一下 synchronized 关键字的底层原理</h2></li><li><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</li><li><code>synchronized</code> 修饰的方法<strong>并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令</strong>，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</li></ol><p>执行 <code>monitorenter</code> 指令时，线程试图<strong>获取锁</strong>也就是<strong>获取 对象监视器 monitor 的持有权</strong>（两者本质）</p><ul><li>在执行 <code>monitorenter</code> 时，会尝试<strong>获取对象的锁</strong>，如果锁的计数器为 0 则表示<strong>锁可被获取</strong>，获取后将锁计数器b 也就是加 1。</li><li>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来<strong>释放锁</strong>。在执行 monitorexit 指令后，将锁计数器<strong>设为 0</strong>，表明锁被释放，其他线程可以尝试获取锁。</li><li>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。<h2 id="5-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"><a href="#5-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗？" class="headerlink" title="5.  JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？"></a>5.  JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗？</h2>JDK1.6 对锁的实现引入了大量的优化，如<strong>偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化</strong>等技术来<strong>减少锁操作的开销</strong>。<br>锁主要存在四种状态，依次是：<strong>无锁</strong>状态、<strong>偏向锁</strong>状态、<strong>轻量级锁</strong>状态、<strong>重量级锁</strong>状态，他们会随着竞争的激烈而逐渐升级。注意<strong>锁可升级不可降级</strong>，这种策略是为了<strong>提高获得锁和释放锁的效率</strong>。<h2 id="6-synchronized（同步锁）和-ReentrantLock（重入锁）的区别"><a href="#6-synchronized（同步锁）和-ReentrantLock（重入锁）的区别" class="headerlink" title="6. synchronized（同步锁）和 ReentrantLock（重入锁）的区别"></a>6. synchronized（同步锁）和 ReentrantLock（重入锁）的区别</h2></li></ul><ol><li>两者都是可重入锁</li><li><code>synchronized</code> 依赖于 <strong>JVM</strong>，<code>ReentrantLock</code> 依赖于 <strong>API</strong></li><li><code>ReentrantLock</code> 比 <code>synchronized</code> 增加了一些高级功能：</li></ol><ul><li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而 <code>synchronized</code> 只能是非公平锁。所谓的公平锁就是<strong>先等待的线程先获得锁</strong>。<code>ReentrantLock</code> 默认情况是非公平的，可以通过 <code>ReentrantLock</code> 类的<code>ReentrantLock(boolean fair)</code> 构造方法来制定是否是公平的。</li><li><strong>可实现选择性通知</strong>（锁可以绑定多个条件）：<code>synchronized</code> 关键字与<code> wait()</code> 和<code>notify()/notifyAll()</code> 方法相结合可以实现<strong>等待&#x2F;通知机制</strong>。<code>ReentrantLock</code> 类当然也可以实现，但是需要借助于<code>Condition</code> 接口与 <code>newCondition()</code> 方法。<h1 id="volatile-不同步的-关键字"><a href="#volatile-不同步的-关键字" class="headerlink" title="volatile(不同步的) 关键字"></a>volatile(不同步的) 关键字</h1><h2 id="1-CPU-缓存模型"><a href="#1-CPU-缓存模型" class="headerlink" title="1. CPU 缓存模型"></a>1. CPU 缓存模型</h2><strong>CPU Cache 缓存</strong>的是内存数据用于解决 <strong>CPU 处理速度和内存不匹配的问题</strong>，<strong>内存缓存</strong>的是硬盘数据用于解决<strong>硬盘访问速度过慢</strong>的问题。<br>我们甚至可以把<strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。<br><strong>CPU Cache 的工作方式：</strong><br>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory(主存) 中。但是，这样存在 内存缓存不一致性的问题（制定缓存一致协议或者其他手段来解决）！<h2 id="2-讲一下-JMM-Java-内存模型-java-memory-model"><a href="#2-讲一下-JMM-Java-内存模型-java-memory-model" class="headerlink" title="2. 讲一下 JMM(Java 内存模型)(java memory model)"></a>2. 讲一下 JMM(Java 内存模型)(java memory model)</h2>Java 内存模型<strong>抽象了线程和主内存之间的关系</strong>，就比如说<strong>线程之间的共享变量必须存储在主内存中</strong>。<br>Java 内存模型主要目的：<strong>屏蔽系统和硬件的差异</strong>，避免一套代码在不同的平台下产生的效果不一致。</li></ul><p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成<strong>一个</strong>线程<strong>在主存中修改了一个变量的值</strong>，而<strong>另一个</strong>线程还继续使用它在<strong>寄存器中的变量值的拷贝</strong>，造成数据的不一致。</p><ul><li><strong>主内存</strong>：所有线程创建的<strong>实例对象</strong>都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li><li><strong>本地内存</strong>：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，<strong>每个线程只能访问自己的本地内存</strong>，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，<strong>存储了主内存中的共享变量副本</strong>。</li></ul><p><strong>解决</strong>：把变量声明为 <code>volatile</code> ，这就指示 JVM，这个变量是<strong>共享且不稳定</strong>的，每次使用它<strong>都到主存</strong>中进行读取。<br><code>volatile</code> 关键字：① <strong>防止 JVM 的指令重排</strong> ，② <strong>保证变量的可见性</strong>。<br><img src="https://img-blog.csdnimg.cn/5303f4a5ce28460fa529b9183cb4ec1a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/1d19bdda5dad4eb8ab22e2815bd42094.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h2 id="3-并发编程的三个重要特性"><a href="#3-并发编程的三个重要特性" class="headerlink" title="3. 并发编程的三个重要特性"></a>3. 并发编程的三个重要特性</h2><ol><li><strong>原子性</strong>：一次操作或者多次操作，要么所有的操作<strong>全部执行</strong>并且不会受到任何因素的干扰而中断，要么<strong>都不执行</strong>。<code>synchronized</code> 可以保证代码片段的原子性。</li><li><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的<strong>其它线程</strong>都是立即<strong>可以看到修改后的最新值</strong>。<code>volatile</code> 关键字可以保证共享变量的可见性。</li><li><strong>有序性</strong>：<strong>代码在执行的过程中的先后顺序</strong>，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。<h2 id="4-synchronized-关键字和-volatile-关键字的区别"><a href="#4-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="4. synchronized 关键字和 volatile 关键字的区别"></a>4. synchronized 关键字和 volatile 关键字的区别</h2><code>synchronized</code> (同步的) 关键字和 <code>volatile</code> (不同步的) 关键字是两个<strong>互补</strong>的存在。</li></ol><ul><li><code>volatile</code> 关键字是线程同步的<strong>轻量级(s..重量级)<strong>实现，所以 <code>volatile</code> 比 <code>synchronized</code> 关键字</strong>性能要好</strong> 。但是 <code>volatile</code> 关键字只能用于<strong>变量</strong>而 <code>synchronized</code> 关键字可以修饰<strong>方法以及代码块</strong> 。</li><li><code>volatile</code> 关键字能保证数据的<strong>可见性</strong>，但不能保证数据的<strong>原子性</strong>。<code>synchronized</code> 关键字两者都能保证。</li><li><code>volatile</code> 关键字主要用于<strong>解决变量在多个线程之间的可见性</strong>，而 <code>synchronized</code> <strong>关键字解决多个线程之间访问资源的同步性</strong>。<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><h2 id="1-ThreadLocal-简介"><a href="#1-ThreadLocal-简介" class="headerlink" title="1. ThreadLocal 简介"></a>1. ThreadLocal 简介</h2>实现每一个线程都有自己的专属本地变量，让每个线程绑定自己的值。<br>如果你创建了一个<code>ThreadLocal</code> 变量，那么访问这个变量的每个线程都会有这个变量的<strong>本地副本</strong>，这也是<code>ThreadLocal</code> 变量名的由来。他们可以使用 <code>get()</code> 和 <code>set()</code> 方法来获取默认值或将其值<strong>更改为当前线程所存的副本的值</strong>，从而避免了<strong>线程安全</strong>问题。<h2 id="2-ThreadLocal-原理"><a href="#2-ThreadLocal-原理" class="headerlink" title="2. ThreadLocal 原理"></a>2. ThreadLocal 原理</h2>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，**<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code> 的封装，传递了变量值。** <code>ThrealLocal</code> 类中可以通过 <code>Thread.currentThread()</code> 获取到当前线程对象后，直接通过 <code>getMap(Thread t)</code> 可以访问到该线程的 <code>ThreadLocalMap</code> 对象。</li></ul><p>每个Thread中都具备一个 <code>ThreadLocalMap</code> ，而<code> ThreadLocalMap</code>可以存储以 <strong><code>ThreadLocal</code> 为 key</strong>，<strong>Object 对象为 value 的键值对</strong>。</p><h2 id="3-ThreadLocal-内存泄露问题"><a href="#3-ThreadLocal-内存泄露问题" class="headerlink" title="3. ThreadLocal 内存泄露问题"></a>3. ThreadLocal 内存泄露问题</h2><p><strong>内存泄露</strong>：<code>ThreadLocalMap</code> 中使用的 key 为弱引用，而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在<strong>垃圾回收</strong>的时候，key 会被清理掉，而 value 不会被清理掉。<code>ThreadLocalMap</code> 中就会出现 key 为 <code>null</code> 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。<br><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code> 方法后 最好手动调用 <code>remove()</code> 方法。</p><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="1-为什么要用线程池？"><a href="#1-为什么要用线程池？" class="headerlink" title="1. 为什么要用线程池？"></a>1. 为什么要用线程池？</h2><p><strong>线程池</strong>：提供了一种<strong>限制和管理资源</strong>（包括执行一个任务）的方式。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。<br><strong>池化技术</strong>：减少每次获取资源的消耗，提高对资源的利用率。<br><strong>好处</strong>：</p><ol><li><strong>降低资源消耗</strong>。通过<strong>重复利用已创建的线程</strong>降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以<strong>不需要等到线程创建就能立即执行</strong>。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行<strong>统一分配、调优和监控</strong>。<h2 id="2-实现-Runnable-接口和-Callable-接口的区别"><a href="#2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="2. 实现 Runnable 接口和 Callable 接口的区别"></a>2. 实现 Runnable 接口和 Callable 接口的区别</h2></li></ol><ul><li><code>Callable</code> 仅在 Java 1.5 中引入，目的就是为了来处理<code> Runnable</code> (1.0)<strong>不支持的用例</strong>。</li><li><code>Runnable</code> 接口 <strong>不会返回结果或抛出检查异常</strong>，但是 <code>Callable</code> 接口 可以。</li><li>工具类 <code>Executors </code> ：将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。<br>（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）<h2 id="3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="3. 执行 execute()方法和 submit()方法的区别是什么呢？"></a>3. 执行 execute()方法和 submit()方法的区别是什么呢？</h2></li><li><code>execute()</code> 方法用于提交<strong>不需要返回值的任务</strong>，所以<strong>无法判断</strong>任务是否被线程池执行<strong>成功与否</strong>；</li><li><code>submit()</code> 方法用于提交<strong>需要返回值的任务</strong>。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功，并且可以通过 <code>Future</code> 的 <code>get()</code> 方法来获取返回值，<code>get()</code> 方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code> 方法<strong>（超时等待）</strong>则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。<h2 id="4-如何创建线程池"><a href="#4-如何创建线程池" class="headerlink" title="4. 如何创建线程池"></a>4. 如何创建线程池</h2>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 的方式，这样的处理方式让写的同学更<strong>加明确线程池的运行规则，规避资源耗尽的风险</strong>。<h2 id="5-线程池原理分析"><a href="#5-线程池原理分析" class="headerlink" title="5. 线程池原理分析"></a>5. 线程池原理分析</h2>线程池首先会先执行 5 个（**<code>corePoolSize</code>核心线程数**）任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。<br><img src="https://img-blog.csdnimg.cn/4bb194abb0144531859b9eadaad3f8f2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="线程池原理"><h1 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h1><h2 id="1-介绍一下-Atomic-原子类"><a href="#1-介绍一下-Atomic-原子类" class="headerlink" title="1. 介绍一下 Atomic 原子类"></a>1. 介绍一下 Atomic 原子类</h2><strong>原子性</strong>：要么都执行（且不被其他线程干扰）要么都不执行。<br><strong>原子类</strong>：具有原子性的类。并发包原子类都存放在 <code>java.util.concurrent.atomic</code> <h2 id="2-JUC-包中的原子类是哪-4-类？"><a href="#2-JUC-包中的原子类是哪-4-类？" class="headerlink" title="2. JUC 包中的原子类是哪 4 类？"></a>2. JUC 包中的原子类是哪 4 类？</h2><strong>基本类型</strong>：<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicBoolean</code><br><strong>数组类型</strong>：<code>AtomicIntegerArray</code>、<code>AtomicLongArray</code>、<code>AtomicReferenceArray</code><br><strong>引用类型</strong>：<code>AtomicReference</code>、<code>AtomicStampedReference</code>、<code>AtomicMarkableReference</code><br><strong>对象的属性修改类型</strong>：<code>AtomicIntegerFieldUpdater</code>、<code>AtomicLongFieldUpdater</code>、<code>AtomicReferenceFieldUpdater</code><h2 id="3-讲讲-AtomicInteger-的使用"><a href="#3-讲讲-AtomicInteger-的使用" class="headerlink" title="3. 讲讲 AtomicInteger 的使用"></a>3. 讲讲 AtomicInteger 的使用</h2><code>AtomicInteger</code> 类常用方法（使用 <code>AtomicInteger</code> 之后，不需要对该方法加锁，也可以实现线程安全。）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAdd</span><span class="params">(<span class="type">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> expect, <span class="type">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lazySet</span><span class="params">(<span class="type">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span><br></pre></td></tr></table></figure><h2 id="4-简单介绍一下-AtomicInteger-类的原理"><a href="#4-简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="4. 简单介绍一下 AtomicInteger 类的原理"></a>4. 简单介绍一下 AtomicInteger 类的原理</h2><code>AtomicInteger</code> 类主要利用 <strong><code>CAS</code>  (比较 交换)+ <code>volatile</code> （可见性）和 <code>native</code> 方法</strong>来保证原子操作，从而避免 <code>synchronized</code> 的高开销（比较），执行效率大为提升。<br>CAS：拿期望的值和原本的一个值作比较，如果相同则更新成新的值。（UnSafe 类的 <code>objectFieldOffset()</code> 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 <code>valueOffset</code>。）<br>value 是一个 <code>volatile</code> 变量，在内存中可见。<br>JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</li></ul><h1 id="AQS-AbstractQueuedSynchronizer-抽象队列同步器"><a href="#AQS-AbstractQueuedSynchronizer-抽象队列同步器" class="headerlink" title="AQS(AbstractQueuedSynchronizer) 抽象队列同步器"></a>AQS(AbstractQueuedSynchronizer) 抽象队列同步器</h1><h2 id="1-AQS-介绍"><a href="#1-AQS-介绍" class="headerlink" title="1. AQS 介绍"></a>1. AQS 介绍</h2><p><code>java.util.concurrent.locks</code> 包下面<br>AQS 是一个<strong>用来构建锁和同步器的框架</strong>，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，<code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code>。</p><h2 id="2-AQS-原理分析"><a href="#2-AQS-原理分析" class="headerlink" title="2. AQS 原理分析"></a>2. AQS 原理分析</h2><p>AQS 核心思想是：</p><ul><li>如果被请求的共享资源<strong>空闲</strong>，则将<strong>当前请求资源的线程设置为有效</strong>的工作线程，并且将<strong>共享资源设置为锁定状态</strong>。</li><li>如果被请求的共享资源被<strong>占用</strong>，那么就需要一套<strong>线程阻塞等待</strong>以及<strong>被唤醒时锁分配</strong>的机制（<strong>CLH 队列锁</strong>实现），即<strong>将暂时获取不到锁的线程加入到队列</strong>中。</li></ul><p><strong>CLH</strong>(Craig,Landin and Hagersten)队列是一个<strong>虚拟的双向队列</strong>（即不存在队列实例，仅存在<strong>结点之间的关联</strong>关系）。AQS 是将<strong>每条请求共享资源的线程</strong>封装成一个 <strong>CLH 锁队列的一个结点（Node）</strong>来实现锁的分配。<br><img src="https://img-blog.csdnimg.cn/098a08725a494f2690be307757b1c3cb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="CLH"></p><h2 id="3-AQS-定义两种资源共享方式"><a href="#3-AQS-定义两种资源共享方式" class="headerlink" title="3. AQS 定义两种资源共享方式"></a>3. AQS 定义两种资源共享方式</h2><ol><li><strong>Exclusive（独占）</strong>：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<br>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<br>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li><li><strong>Share（共享）</strong>：多个线程可同时执行，如 <code>CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。（<code>ReentrantReadWriteLock</code>：读写锁允许多个线程同时对某一资源进行读）</li></ol><h2 id="4-用过-CountDownLatch-么？什么场景下用的？"><a href="#4-用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="4. 用过 CountDownLatch 么？什么场景下用的？"></a>4. 用过 CountDownLatch 么？什么场景下用的？</h2><p><code>CountDownLatch</code> 的作用就是 <strong>允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕</strong>。</p><h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><p>虚拟机自动内存管理机制下，不再需要像 C&#x2F;C++程序为每一个 <code>new</code> 操作去写对应的 <code>delete/free</code> 操作，不容易出现<strong>内存泄漏</strong>和<strong>内存溢出</strong>问题。</p><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><p><img src="https://img-blog.csdnimg.cn/f132ef9902ac4c6abe8e0f3692d1f515.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="数据区域"><br>线程<strong>私有</strong>的：① 程序计数器；② 虚拟机栈；③ 本地方法栈。<br>线程<strong>共享</strong>的：① 堆；② 方法区；③直接内存 (非运行时数据区的一部分)</p><ol><li><strong>程序计数器</strong></li></ol><ul><li>字节码解释器通过改变程序计数器来依次<strong>读取指令</strong>，从而实现代码的<strong>流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。<br>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的<strong>创建&#x2F;结束而创建&#x2F;死亡</strong>。</li></ul><ol start="2"><li><strong>Java 虚拟机栈</strong></li></ol><ul><li><strong>生命周期和线程相同</strong>，描述的是 <strong>Java 方法执行的内存模型</strong>，每次方法调用的数据都是通过<strong>栈传递</strong>的。（<strong>堆内存</strong> 和 <strong>栈内存</strong>）</li><li><strong>栈帧</strong>组成，而每个栈帧中都拥有：<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>方法出口</strong>信息（java方法的）。</li><li><strong>两种错误</strong>：<code>StackOverFlowError</code> 栈深错误  <code>OutOfMemoryError</code> 内存不足。</li><li>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出（释放内存空间）。</li></ul><ol start="3"><li><p><strong>本地方法栈</strong><br><strong>虚拟机栈</strong>为虚拟机执行 <strong>Java 方法</strong> （也就是字节码）服务，<br><strong>本地方法栈</strong>则为虚拟机使用到的 <strong>Native 方法</strong>服务。<br>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该<strong>本地方法的</strong>局部变量表、操作数栈、动态链接、出口信息。调用结束后，也都会有一个栈帧被弹出（释放内存空间）。</p></li><li><p><strong>堆</strong><br><strong>存放对象实例</strong>，几乎所有的对象实例以及数组都在这里分配内存。<br>Java 堆是<strong>垃圾收集器</strong>管理的主要区域，因此也被称作 GC 堆。<br>垃圾回收收集器基本都采用 <strong>分代垃圾收集算法</strong>。<br>Java堆可细分：新生代(Eden, Survivor)、老年代(Old) 和 永久代(1.7前)&#x2F;元空间(1.8后)。<br>JDK 8 版本之后 <code>PermGen</code>(永久代) 已被 <code>Metaspace</code>(元空间) 取代，<strong>元空间</strong>使用的是<strong>直接内存</strong>。<br>对象都会首先在 <code>Eden</code> 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(<code>Eden</code> 区-&gt;<code>Survivor</code> 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。<br><img src="https://img-blog.csdnimg.cn/b0fd376278be47c3ad9c3b016b898b38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_7,color_FFFFFF,t_70,g_se,x_16" alt="Hostspot VM堆结构"></p></li><li><p>方法区<br>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p></li><li><p>运行时常量池（方法区的一部分）<br>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p></li><li><p>直接内存</p><h2 id="3-Java-对象的创建过程（能默写）"><a href="#3-Java-对象的创建过程（能默写）" class="headerlink" title="3. Java 对象的创建过程（能默写）"></a>3. Java 对象的创建过程（能默写）</h2><p><strong>类加载检查</strong> → <strong>分配内存</strong> → <strong>初始化零值</strong> → <strong>设置对象头</strong> → <strong>执行 <code>init</code> 方法</strong></p></li><li><p><strong>类加载检查</strong>：<br>虚拟机遇到 <code>new</code> 指令时，首先将去检查这个指令的参数是否能在<strong>常量池中定位</strong>到这个类的符号引用，并且检查这个符号引用代表的类<strong>是否已被加载过、解析和初始化过</strong>。如果没有，那必须先执行相应的类加载过程。<br><img src="https://img-blog.csdnimg.cn/c01b6bef911742f688d61b6ad8030eff.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_18,color_FFFFFF,t_70,g_se,x_16" alt="类的生命周期"></p></li><li><p><strong>分配内存</strong><br>为对象分配空间的任务等同于把一块确定大小的内存从 <strong>Java 堆中</strong>划分出来。<br>内存分配的两种方式：</p></li></ol><ul><li><strong>指针碰撞</strong> ：<br><strong>适用场合</strong> ：堆内存规整（即没有内存碎片）的情况下。<br><strong>原理</strong> ：过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。<br><strong>使用该分配方式的 GC 收集器</strong>：Serial, ParNew</li><li><strong>空闲列表</strong> ：<br><strong>适用场合</strong> ：堆内存不规整的情况下。<br><strong>原理</strong>：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。<br><strong>使用该分配方式的 GC 收集器</strong>：CMS</li></ul><ol start="3"><li><strong>初始化零值</strong><br>分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。程序访问到数据类型所对应的零值。</li><li><strong>设置对象头</strong><br>信息存放（对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息）在对象头中。</li><li><strong>执行 <code>init</code> 方法</strong><br>执行 <code>new</code> 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的<strong>意愿初始化</strong>。<h2 id="4-对象的内存布局"><a href="#4-对象的内存布局" class="headerlink" title="4. 对象的内存布局"></a>4. 对象的内存布局</h2>3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。<br><strong>对象头</strong>：① 对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等） ② 类型指针。<br><strong>实例数据</strong>：对象真正存储的有效信息。<br><strong>对齐填充</strong>：仅占位作用。<h2 id="5-对象的访问定位"><a href="#5-对象的访问定位" class="headerlink" title="5. 对象的访问定位"></a>5. 对象的访问定位</h2>Java 程序通过栈上的 <code>reference</code> 数据来操作堆上的具体对象。<br>对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用<strong>句柄</strong>、<strong>直接指针</strong>。</li></ol><ul><li><strong>句柄</strong>：Java 堆中划分出一块内存作为<strong>句柄池</strong>，**<code>reference</code> (引用)<strong>中存储的就是对象的</strong>句柄地址<strong>，而</strong>句柄<strong>中包含了对象实例数据与类型</strong>数据各自的具体地址信息**。<br>（<code>reference</code> 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 <code>reference</code> 本身不需要修改）</li><li><strong>直接指针</strong>：<code>reference</code> 中存储的直接就是<strong>对象地址</strong>。<br>（速度快，它节省了一次指针定位的时间开销）<br><img src="https://img-blog.csdnimg.cn/11793e0d206345a3a0c0a5576beda4d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="句柄"><br><img src="https://img-blog.csdnimg.cn/1c9a2711beda4001b0f127c922ec196b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="直接指针"><h1 id="JVM-垃圾回收详解"><a href="#JVM-垃圾回收详解" class="headerlink" title="JVM 垃圾回收详解"></a>JVM 垃圾回收详解</h1><img src="https://img-blog.csdnimg.cn/1f5bd14c8424446c90b85fa375782f40.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="JVM垃圾回收"><h2 id="1-JVM-内存分配与回收"><a href="#1-JVM-内存分配与回收" class="headerlink" title="1. JVM 内存分配与回收"></a>1. JVM 内存分配与回收</h2>Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。<br>最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。<br>收集器基本都采用<strong>分代垃圾收集算法</strong>，Java 堆可细分为：<strong>新生代（Eden、From Survivor、To Survivor）和老年代</strong>。进一步划分的目的是更好地回收和分配内存。<br><img src="https://img-blog.csdnimg.cn/2927b582f1f74dbfb75363fca67eda70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="JAVA堆"><br>对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到<strong>一定程度</strong>（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的<strong>年龄阈值</strong>，可以通过参数 <code>-XX: MaxTenuringThreshold</code> 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过 <code>-XX:+PrintTenuringDistribution</code> 来打印出当次 GC 后的 <code>Threshold</code>。<br>（Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个<strong>年龄大小超过了 survivor 区的一半</strong>时，取这个年龄和 <code>MaxTenuringThreshold</code> 中更小的一个值，作为新的晋升年龄阈值）<br>经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色，也就是新的”To”就是上次 GC 前的“From”，新的”From”就是上次 GC 前的”To”。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC 会一直重复这样的过程，在这个过程中，有可能当次 Minor GC 后，Survivor 的”From”区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。</li></ul><ol><li>对象优先在 eden 区分配</li><li>大对象直接进入老年代</li><li>长期存活的对象将进入老年代</li><li>动态对象年龄判定</li><li>主要进行 gc 的区域</li></ol><ul><li>部分收集 (Partial GC)：<ul><li><strong>新生代</strong>收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集；<br><strong>老年代</strong>收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；<br><strong>混合</strong>收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul></li><li>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</li></ul><ol start="6"><li>空间分配担保<br>（老年代最大可用的连续空间是否大于新生代所有对象总空间，否则再检查是否大于历次晋升到老年代对象的平均大小）</li></ol><h2 id="2-对象已经死亡？"><a href="#2-对象已经死亡？" class="headerlink" title="2. 对象已经死亡？"></a>2. 对象已经死亡？</h2><p>对<strong>堆垃圾回收</strong>前的第一步就是要<strong>判断哪些对象已经死亡</strong>。（即不能再被任何途径使用的对象）。</p><ol><li><strong>引用计数法</strong><br>给对象中添加一个引用计数器，每当有一个地方<strong>引用</strong>它，计数器就<strong>加 1</strong>；<br>当<strong>引用失效</strong>，计数器就<strong>减 1</strong>；<br>任何时候计数器<strong>为 0 的对象</strong>就是不可能再被使用的。<br>（实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它<strong>很难解决对象之间相互循环引用</strong>的问题。）</li><li><strong>可达性分析算法</strong><br>通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为<strong>引用链</strong>。<br>当一个对象到 GC Roots <strong>没有任何引用链相连</strong>的话，则证明此对象是<strong>不可用的，需要被回收</strong>。<br> <img src="https://img-blog.csdnimg.cn/033ee022047b4ad1aa8cee317f4322d2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="引用链"><h2 id="3-哪些对象可以作为-GC-Roots-呢？（栈和方法区的对象，同步锁对象）"><a href="#3-哪些对象可以作为-GC-Roots-呢？（栈和方法区的对象，同步锁对象）" class="headerlink" title="3. 哪些对象可以作为 GC Roots 呢？（栈和方法区的对象，同步锁对象）"></a>3. 哪些对象可以作为 GC Roots 呢？（栈和方法区的对象，同步锁对象）</h2></li></ol><ul><li><strong>虚拟机栈</strong>(栈帧中的本地变量表)中引用的对象</li><li><strong>本地方法栈</strong>(Native 方法)中引用的对象</li><li><strong>方法区</strong>中类静态属性引用的对象</li><li><strong>方法区</strong>中常量引用的对象</li><li>所有被<strong>同步锁</strong>持有的对象<h2 id="4-对象可以被回收，就代表一定会被回收吗？"><a href="#4-对象可以被回收，就代表一定会被回收吗？" class="headerlink" title="4. 对象可以被回收，就代表一定会被回收吗？"></a>4. 对象可以被回收，就代表一定会被回收吗？</h2>真正宣告一个对象死亡，至少要经历<strong>两次标记</strong>过程。<br>可达性分析法中不可达的对象（<strong>死缓</strong>）被<strong>第一次标记</strong>并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖<code> finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。<br>被判定为需要执行的对象将会被放在一个队列中进行<strong>第二次标记</strong>，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。<h2 id="5-再谈引用"><a href="#5-再谈引用" class="headerlink" title="5. 再谈引用"></a>5. 再谈引用</h2></li><li>强引用：绝不回收</li><li>软引用：内存不足才回收，否则不回收。可以和一个<strong>引用队列</strong>（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li><li>弱引用：更短暂的生命周期，一旦发现就回收（<strong>区别</strong>）。也可以联合引用队列回收。</li><li>虚引用：<strong>任何时候</strong>都可能被垃圾回收。必须联合引用队列回收。</li></ul><p>软引用最多，软引用可以<strong>加速</strong> JVM 对垃圾内存的回收速度，可以维护系统的<strong>运行安全</strong>，<strong>防止内存溢出</strong>（OutOfMemory）等问题的产生。</p><h2 id="6-如何判断一个常量是废弃常量？"><a href="#6-如何判断一个常量是废弃常量？" class="headerlink" title="6. 如何判断一个常量是废弃常量？"></a>6. 如何判断一个常量是废弃常量？</h2><p><strong>运行时常量池</strong>主要回收的是<strong>废弃的常量</strong>。<br>假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 <code>String</code> 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。<br>（JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候<strong>字符串常量池还在堆</strong>, <strong>运行时常量池还在方法区</strong>，只不过方法区的实现从永久代变成了元空间(Metaspace)）</p><h2 id="7-如何判断一个类是无用的类？"><a href="#7-如何判断一个类是无用的类？" class="headerlink" title="7. 如何判断一个类是无用的类？"></a>7. 如何判断一个类是无用的类？</h2><p>同时满足下面 3 个条件才能算是 “无用的类” ：</p><ol><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><p>虚拟机可以对满足上述 3 个条件的无用类进行回收。</p><h2 id="8-垃圾收集算法"><a href="#8-垃圾收集算法" class="headerlink" title="8. 垃圾收集算法"></a>8. 垃圾收集算法</h2><h3 id="1-标记-清除算法"><a href="#1-标记-清除算法" class="headerlink" title="1. 标记-清除算法"></a>1. 标记-清除算法</h3><p><img src="https://img-blog.csdnimg.cn/54baf6f0152b411db5115b514637a4a6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="标记清楚"></p><h3 id="2-标记-复制算法"><a href="#2-标记-复制算法" class="headerlink" title="2. 标记-复制算法"></a>2. 标记-复制算法</h3><p><img src="https://img-blog.csdnimg.cn/75d8fe0f3fd0441e8c017f77ebf41188.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="复制"></p><h3 id="3-标记-整理算法"><a href="#3-标记-整理算法" class="headerlink" title="3. 标记-整理算法"></a>3. 标记-整理算法</h3><p><img src="https://img-blog.csdnimg.cn/ecb9b5fd8da649b28b39548e4502dca5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_15,color_FFFFFF,t_70,g_se,x_16" alt="整理"></p><h3 id="4-分代收集算法"><a href="#4-分代收集算法" class="headerlink" title="4. 分代收集算法"></a>4. 分代收集算法</h3><p><strong>新生代</strong>中，每次收集都会有大量对象死去，所以可以选择<strong>标记-复制</strong>算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。<br><strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“<strong>标记-清除</strong>”或“<strong>标记-整理</strong>”算法进行垃圾收集。</p><h2 id="9-垃圾收集器"><a href="#9-垃圾收集器" class="headerlink" title="9. 垃圾收集器"></a>9. 垃圾收集器</h2><p><img src="https://img-blog.csdnimg.cn/4a11ca99cc114040a183a4fc44765354.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="gc器"><br>到jdk8为止，默认的垃圾收集器是<code>Parallel Scavenge</code> 和 <code>Parallel Old</code><br>从jdk9开始，<code>G1</code>收集器成为默认的垃圾收集器 目前来看，<code>G1</code>回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，<code>Parallel Scavenge</code> 回收新生代停顿长达1.5秒。<code>G1</code>回收器回收同样大小的新生代只停顿0.2秒。</p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/e8b93aa48d3a4c4a9b434269d568b5ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="波妞"></p>]]></content>
      
      
      <categories>
          
          <category> JAVASE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda安装及使用教程</title>
      <link href="/2022/02/02/Anaconda%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2022/02/02/Anaconda%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><font color=#999AAA >Anaconda是Python的包管理器和环境管理器。<br>回答下初学者存在的疑问：为什么我安装了Python还需要安装Anaconda呢？<br>答：1.管理运行环境优势巨大。试想你有的羡慕是用Python2运行，有的确是Python3运行。有的使用tensorflow1.x运行，有的却使用tensorflow2.x运行。……你怕不怕？anaconda可创建多个独立的运行环境，用户可轻松切换，是不是很方便？<br>2.管理包。conda可便捷地为你安装&#x2F;卸载&#x2F;更新包。<br>3.Anaconda附带了一大批常用数据科学包。<br></font></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><font color=#999AAA >过去我也不想用anaconda，直到用了，卧槽，真够香的啊<h1 id="一、Anaconda的安装"><a href="#一、Anaconda的安装" class="headerlink" title="一、Anaconda的安装"></a>一、Anaconda的安装</h1><p><font color=#999AAA >不推荐从官网下载（访问国外网站，速度慢）<br>推荐从<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">清华镜像源</a>下载Anaconda<br><img src="https://img-blog.csdnimg.cn/a50dd90f583d42efa9e8b12615e6c5fc.png" alt="在这里插入图片描述"></p><p>1.勾选加入到环境变量；2.将自带的Python3.7设置为系统默认的Python版本（这个看个人所需，有的同学可能预先安装了某个Python版本，不想覆盖掉就不覆盖）后面安装点点点即可，傻瓜式安装。安装完就按 Windows键就可查看到了。<br><img src="https://img-blog.csdnimg.cn/8b0d8c33880e4d4f8d02cd3dfa372533.png" alt="在这里插入图片描述"></p><h1 id="二、修改镜像源地址"><a href="#二、修改镜像源地址" class="headerlink" title="二、修改镜像源地址"></a>二、修改镜像源地址</h1><p>使用anaconda可便捷地管理包。conda的管理包的功能和pip（这个大家熟悉吧）同样。也可以使用pip。<br>和前面所说一样，访问国外的网站速度会很慢，直接安装各种包同样会很慢，因此把下载包的网站换到国内的镜像源网站速度会很快，常用的有清华镜像源、豆瓣镜像源、阿里镜像源……</p><h2 id="1-永久添加镜像源"><a href="#1-永久添加镜像源" class="headerlink" title="1. 永久添加镜像源"></a>1. 永久添加镜像源</h2><p>（以清华镜像源为例，也可换其他）命令，打开命令行cmd，或者前面图中所示的Anaconda Prompt，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --set show_channel_urls yes</span><br></pre></td></tr></table></figure><h2 id="2-pip临时使用"><a href="#2-pip临时使用" class="headerlink" title="2. pip临时使用"></a>2. pip临时使用</h2><p> 用于下载安装包使用，命令：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 这里以豆瓣镜像源为例，增加读者理解</span><br><span class="line">pip install numpy -i https://pypi.douban.com/simple</span><br><span class="line">pip install numpy==1.14.0 -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure></p><h2 id="3-pip也可永久修改，"><a href="#3-pip也可永久修改，" class="headerlink" title="3. pip也可永久修改，"></a>3. pip也可永久修改，</h2><p> 方法：windows下在user目录中创建一个pip目录，如：C:\Users\xx\pip，新建文件pip.ini，内容如下：<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> [global] </span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p><h1 id="三、如何管理环境"><a href="#三、如何管理环境" class="headerlink" title="三、如何管理环境"></a>三、如何管理环境</h1><p>这也是anaconda最大的好处，再也不头疼各种环境来回切换了。</p><h2 id="1-创建环境"><a href="#1-创建环境" class="headerlink" title="1. 创建环境"></a>1. 创建环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create –n python36 python=3.6</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create –n python27 python=2.7.15</span><br></pre></td></tr></table></figure><p>解释：</p><ol><li>命令中，python36为可设置的环境名</li><li>python&#x3D;3.6是指定创建的python版本。若无指定版本，则会安装最新版本的Python3.6.X。</li><li>用户可自行设置自己容易区分的，有时自己电脑创建10来个环境都是正常。<h2 id="2-进入环境"><a href="#2-进入环境" class="headerlink" title="2. 进入环境"></a>2. 进入环境</h2>使用Windows的cmd命令行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate python36</span><br></pre></td></tr></table></figure>使用anaconda安装自带的【anaconda prompt】：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate python36</span><br></pre></td></tr></table></figure>在Linux环境下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate python36</span><br></pre></td></tr></table></figure>展示下效果吧<br><img src="https://img-blog.csdnimg.cn/ab7a21881c834809809ee0801d0adb5e.png" alt="在这里插入图片描述"></li></ol><h2 id="3-离开-x2F-切换环境"><a href="#3-离开-x2F-切换环境" class="headerlink" title="3. 离开&#x2F;切换环境"></a>3. 离开&#x2F;切换环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 离开环境cmd</span><br><span class="line">deactivate python36</span><br><span class="line"># 离开环境anaconda prompt</span><br><span class="line">conda deactivate python36</span><br><span class="line"># 切换环境，直接激活另一个环境即可</span><br><span class="line">conda activate python27</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8a7038e61bc54b8098661b04407974c4.png" alt="在这里插入图片描述"></p><h2 id="4-查看anaconda所创建的所有环境"><a href="#4-查看anaconda所创建的所有环境" class="headerlink" title="4. 查看anaconda所创建的所有环境"></a>4. 查看anaconda所创建的所有环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/61869333491a4ef5ac43fae8b3f82793.png" alt="在这里插入图片描述"></p><p>带 * 表示当前环境</p><h2 id="5-删除环境"><a href="#5-删除环境" class="headerlink" title="5. 删除环境"></a>5. 删除环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env remove -n python36</span><br></pre></td></tr></table></figure><p>解释：python36为环境名称。<br>输入命令最后按 y 确认输出即可，</p><h2 id="6-导出-x2F-使用环境yaml"><a href="#6-导出-x2F-使用环境yaml" class="headerlink" title="6. 导出&#x2F;使用环境yaml"></a>6. 导出&#x2F;使用环境yaml</h2><p>6.1 使用conda</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; environment.yaml</span><br></pre></td></tr></table></figure><p>解释：会在当前环境的导出一个yaml文件，列出环境安装详情。<br>若上传&#x2F;发送项目给其他人，导出环境是非常有必要的，否则项目则难以部署。<br>一键安装yaml文件所有包的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env update -f=/path/to/environment.yml</span><br></pre></td></tr></table></figure><p>解释： -f&#x3D;[yaml文件所在路径]<br>6.2 使用pip<br>使用pip也可导出环境，导出.txt文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip freeze &gt; environment.txt</span><br></pre></td></tr></table></figure><h1 id="四、如何管理包（安装-x2F-卸载-x2F-更新＋查看环境）"><a href="#四、如何管理包（安装-x2F-卸载-x2F-更新＋查看环境）" class="headerlink" title="四、如何管理包（安装&#x2F;卸载&#x2F;更新＋查看环境）"></a>四、如何管理包（安装&#x2F;卸载&#x2F;更新＋查看环境）</h1><h2 id="1-安装-x2F-卸载-x2F-更新"><a href="#1-安装-x2F-卸载-x2F-更新" class="headerlink" title="1.安装&#x2F;卸载&#x2F;更新"></a>1.安装&#x2F;卸载&#x2F;更新</h2><p><font color=#999AAA >命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装（以numpy包为例）（在当前使用环境下安装）</span><br><span class="line"># 不指定包的版本则会自动安装最新</span><br><span class="line">conda install numpy</span><br><span class="line">conda install numpy==1.14.0</span><br><span class="line"># 卸载</span><br><span class="line">conda remove numpy</span><br><span class="line"># 更新</span><br><span class="line">conda update numpy</span><br></pre></td></tr></table></figure><h2 id="2-查看已经安装的包"><a href="#2-查看已经安装的包" class="headerlink" title="2.查看已经安装的包"></a>2.查看已经安装的包</h2><p><font color=#999AAA >命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前环境下已安装的包（所有）</span><br><span class="line">conda list </span><br><span class="line"># 查看当前环境下已安装的包（某个，如numpy）</span><br><span class="line">conda list numpy</span><br><span class="line"># 查看某个环境已安装的包</span><br><span class="line">conda list -n python36</span><br><span class="line">#  查找package信息</span><br><span class="line">conda search numpy</span><br></pre></td></tr></table></figure><h1 id="五、pycharm配置"><a href="#五、pycharm配置" class="headerlink" title="五、pycharm配置"></a>五、pycharm配置</h1><p>anaconda所安装的所有环境全部会在anaconda的安装路径<br><img src="https://img-blog.csdnimg.cn/b197d2e2a3ad4ea0b37416dade0a6478.png" alt="在这里插入图片描述"><br>下面讲解pycharm配置（下附有图）：<br>（我用的是pycharm2020,20版本以上有中文插件，<br>想设置，看上条博客。中文上手很快）<br><a href="https://blog.csdn.net/qq_39493185/article/details/121821305">中文汉化教程</a>，请点击这里</p><ol><li>点击 【文件】→【设置】</li><li>【项目】→【Python解释器】→【点击小齿轮】→【+号】</li><li>找到安装的环境路径，点击【python.exe】→【确定】</li><li>在列表里选择要用的那个环境即可<br><img src="https://img-blog.csdnimg.cn/a75cf5e8e7b84afcb5c212d5dec03c5b.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/9dab7c8bc3a84528b5a0bec24f7c0353.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8387a8f858f24a2c958840e06597c669.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_19,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/8083b94573ac48b68d6903362b1c33e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.csdn.net/xc_zhou/article/details/82715612">https://blog.csdn.net/xc_zhou/article/details/82715612</a><br><a href="https://blog.csdn.net/wq_ocean_/article/details/103889237">https://blog.csdn.net/wq_ocean_/article/details/103889237</a></p><hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1"><h1 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h1><p><img src="https://img-blog.csdnimg.cn/8e71420ca2e44bc5ba17ef01fb68a9c1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pycharm2020版本汉化教程</title>
      <link href="/2022/01/19/pycharm2020%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8A%E4%B8%AD%E6%96%87%E7%89%88%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/19/pycharm2020%E7%89%88%E6%9C%AC%E4%BB%A5%E4%B8%8A%E4%B8%AD%E6%96%87%E7%89%88%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>许多同学刚使用pycharm由于界面全英文而难以上手，pycharm2020版本以上具有汉化插件了。<br>官方的，汉化起来更舒心。<br>使用中文版，上手更快</p><h1 id="一、pycharm安装"><a href="#一、pycharm安装" class="headerlink" title="一、pycharm安装"></a>一、pycharm安装</h1><p><font color=#999AAA >要求安装2020版本以上，直接<a href="http://www.jetbrains.com/pycharm/download/#section=windows">官网下载</a>即可。</p><p><img src="https://img-blog.csdnimg.cn/85ae9040b2c9420ea1edf394236b32cf.png" alt="1"><br>左边为专业版，需要输入激活码。<br>右边为社区版，免费，但可能少部分功能会没有，但不影响学生党正常使用。</p><h1 id="二、汉化步骤"><a href="#二、汉化步骤" class="headerlink" title="二、汉化步骤"></a>二、汉化步骤</h1><p>我已汉化，读者自主以未汉化的英文来操作。<br>全中文很舒服。</p><h2 id="1-【文件】→【设置】"><a href="#1-【文件】→【设置】" class="headerlink" title="1.【文件】→【设置】"></a>1.【文件】→【设置】</h2><p><img src="https://img-blog.csdnimg.cn/214b577e3b4744e792b666d822cfef08.png" alt="在这里插入图片描述"></p><h2 id="2-【输入plugins-也可自行下翻找到-→【点击插件-plugins-】→【输入Chinese】→【安装插件】"><a href="#2-【输入plugins-也可自行下翻找到-→【点击插件-plugins-】→【输入Chinese】→【安装插件】" class="headerlink" title="2. 【输入plugins](也可自行下翻找到)→【点击插件(plugins)】→【输入Chinese】→【安装插件】"></a>2. 【输入plugins](也可自行下翻找到)→【点击插件(plugins)】→【输入Chinese】→【安装插件】</h2><h2 id="3-安装后按照提示，重启pycharm，即是中文版了。"><a href="#3-安装后按照提示，重启pycharm，即是中文版了。" class="headerlink" title="3. 安装后按照提示，重启pycharm，即是中文版了。"></a>3. 安装后按照提示，重启pycharm，即是中文版了。</h2><p><img src="https://img-blog.csdnimg.cn/98d91d00b3a04a098a05c7c54e7b32c2.png" alt="在这里插入图片描述"></p><h2 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h2><p>分享一只爆爆：金克斯的含义就是金克斯<br><img src="https://img-blog.csdnimg.cn/cfc2e498c1374336aa3c592832e0702f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="爆爆"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows 10安装NVIDIA显卡驱动+cuda10.0教程</title>
      <link href="/2022/01/04/windows10%E5%AE%89%E8%A3%85NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8+cuda10.0%E6%95%99%E7%A8%8B/"/>
      <url>/2022/01/04/windows10%E5%AE%89%E8%A3%85NVIDIA%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8+cuda10.0%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1、安装个鲁大师"><a href="#1、安装个鲁大师" class="headerlink" title="1、安装个鲁大师"></a>1、安装个鲁大师</h1><p>查看下显卡驱动的版本。安装cuda10需要驱动版本大于411。否则就卸载。</p><h1 id="2、确定本机是否支持GPU加速"><a href="#2、确定本机是否支持GPU加速" class="headerlink" title="2、确定本机是否支持GPU加速"></a>2、确定本机是否支持GPU加速</h1><p>右击“此电脑”—-选择“管理”—选择设备管理器—选择“显示适配器”就可以查看你的电脑是不是英伟达显卡（必须是英伟达的显卡，并且高于gtx950M以上级别）<br><img src="https://img-blog.csdnimg.cn/b8941287a3694c7abc39b43d6534e68b.png" alt="在这里插入图片描述"></p><h1 id="3、更换至匹配的显卡驱动"><a href="#3、更换至匹配的显卡驱动" class="headerlink" title="3、更换至匹配的显卡驱动"></a>3、更换至匹配的显卡驱动</h1><p>此次安装cuda10，因此版本大于411.31版本<br><img src="https://img-blog.csdnimg.cn/7d96578b68114624a9daf7a36a60636e.png" alt="在这里插入图片描述"></p><p>下载【鲁大师】卸载当前的老显卡驱动<br>下载相应版本：<code>https://www.geforce.cn/drivers</code><br>搜索后，下拉即可显示一堆驱动下载链接，选择一个就行。<br>下载后，全部默认【下一步】，最后一步不点击加入用户体验。<br><img src="https://img-blog.csdnimg.cn/68ca8a49f08a49d893c1bc3edf4886df.png" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/fb3cef1ab43748c0a3145cb62ceced3d.png" alt="在这里插入图片描述"></p><p>到此步，匹配的显卡驱动已经安装完毕。<br>接下来安装cuda和cudnn</p><h1 id="4、下载和安装cuda和cudnn"><a href="#4、下载和安装cuda和cudnn" class="headerlink" title="4、下载和安装cuda和cudnn"></a>4、下载和安装cuda和cudnn</h1><p>如果第3步检测出来支持GPU加速，需要下载和安装cuda和cudnn。<br>下载链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">链接：https://pan.baidu.com/s/141yBtj7yRDCtsC2FXl2h1w </span><br><span class="line">提取码：1203</span><br></pre></td></tr></table></figure><p>安装cuda的时候要定要住，选择自定义安装，其他默认。参考截图：<br><img src="https://img-blog.csdnimg.cn/3a6f5b3dc0014b9799e2ec16b24f8680.png" alt="在这里插入图片描述"></p><p>安装好cuda后，解压缩cudnn，得到一个cuda文件夹，复制里面的全部文件。粘贴到如下位置：<br>粘贴的时候，选择覆盖即可。<br><img src="https://img-blog.csdnimg.cn/65074d8727c94017906768afa860346f.png" alt="在这里插入图片描述"></p><h1 id="5、验证"><a href="#5、验证" class="headerlink" title="5、验证"></a>5、验证</h1><p>win+R输入cmd，回车打开命令提示符。<br>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure><p>显示如下即代表cuda安装完成<br><img src="https://img-blog.csdnimg.cn/80900a26a0f34b88b8decf69ad6d07bf.png" alt="在这里插入图片描述"></p><p>使用win+R，输入cmd，打开黑框。输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.0\extras\demo_suite</span><br></pre></td></tr></table></figure><p>再输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\bandwidthTest.exe</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/f757a945dfc948afacc2a5820c1cd5c2.png" alt="在这里插入图片描述"></p><p>则表示cuda配置成功。即可开始快乐的深度学习和游戏加速。<br>跑深度学习torch框架，可以如下检测是否可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(python36) C:\Users\Administrator&gt;python</span><br><span class="line">Python 3.6.13 |Anaconda, Inc.| (default, Mar 16 2021, 11:37:27) [MSC v.1916 64 bit (AMD64)] on win32</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; import torch</span><br><span class="line">&gt;&gt;&gt; torch.cuda.is_available()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>如果支持加速则会返回<code>True</code><br><img src="https://img-blog.csdnimg.cn/dcaeb2640cad4243b918d8a665b345f8.png" alt="此在cmd命令行作展示"></p><h1 id="6、分享个漂亮的壁纸"><a href="#6、分享个漂亮的壁纸" class="headerlink" title="6、分享个漂亮的壁纸"></a>6、分享个漂亮的壁纸</h1><p><img src="https://img-blog.csdnimg.cn/55cc7373487e4cd79252f42ea7644127.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NVIDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/01/01/hello-world/"/>
      <url>/2022/01/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 介绍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 介绍 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
