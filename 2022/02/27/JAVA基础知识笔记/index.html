<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="JAVA基础知识笔记, 衣羊干洗">
    <meta name="description" content="
Java基础基础概念与常识1. Java 语言有哪些特点?1.简单易学；2. 面向对象（封装，继承，多态）；3.平台无关性（ Java 虚拟机实现平台无关性）；4.支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    

    <title>JAVA基础知识笔记 | 衣羊干洗</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.1.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">衣羊干洗</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">衣羊干洗</div>
        <div class="logo-desc">
            
            选择比努力更重要
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/11.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">JAVA基础知识笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/JAVA/">
                                <span class="chip bg-color">JAVA</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/JAVASE/" class="post-category">
                                JAVASE
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-02-27
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <hr>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h2 id="1-Java-语言有哪些特点"><a href="#1-Java-语言有哪些特点" class="headerlink" title="1. Java 语言有哪些特点?"></a>1. Java 语言有哪些特点?</h2><p>1.简单易学；2. 面向对象（封装，继承，多态）；3.平台无关性（ Java 虚拟机实现平台无关性）；4.支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；5.可靠性；6.安全性；7.支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；8.编译与解释并存；<br>“Write Once, Run Anywhere（一次编写，随处运行）”是最大优势。</p>
<h2 id="2-JVM-vs-JRE-vs-JDK"><a href="#2-JVM-vs-JRE-vs-JDK" class="headerlink" title="2. JVM vs JRE vs JDK"></a>2. JVM vs JRE vs JDK</h2><p><strong>JVM</strong>：运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。<strong>字节码和不同系统的 JVM 实现</strong>是 Java 语言“一次编译，随处可以运行”的关键所在。<br><strong>JRE</strong>： Java 运行时环境。<strong>JRE&#x3D;JVM+java类库、java命令、其他一些基础构建</strong>（它是运行已编译 Java 程序所需的所有内容的集合）<br><strong>JDK</strong>：能够创建和编译程序。<strong>JDK &#x3D; JRE + 编译器（javac）和工具（如 javadoc 和 jdb）</strong></p>
<h2 id="3-什么是字节码-采用字节码的好处是什么"><a href="#3-什么是字节码-采用字节码的好处是什么" class="headerlink" title="3. 什么是字节码?采用字节码的好处是什么?"></a>3. 什么是字节码?采用字节码的好处是什么?</h2><p><strong>字节码</strong>：JVM 可以理解的代码（.class 的文件）。<strong>不面向任何特定的处理器，只面向虚拟机</strong>。<br><strong>好处</strong>：通过字节码的方式，在一定程度上<strong>解决了传统解释型语言执行效率低</strong>的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于<strong>字节码并不针对一种特定的机器</strong>，因此，Java 程序<strong>无须重新编译便可在</strong>多种不同操作系统的计算机上运行。<br><img src="https://img-blog.csdnimg.cn/bd44a5a004964c8fa637058872982ed2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_16,color_FFFFFF,t_70,g_se,x_16" alt="JAVA程序从源代码到运行"></p>
<h2 id="4-为什么说-Java-语言“编译与解释并存”？"><a href="#4-为什么说-Java-语言“编译与解释并存”？" class="headerlink" title="4. 为什么说 Java 语言“编译与解释并存”？"></a>4. 为什么说 Java 语言“编译与解释并存”？</h2><p><strong>编译型</strong> ：编译型语言会通过<strong>编译器</strong>将<strong>源代码一次性翻译成</strong>可被该平台执行的<strong>机器码</strong>。(执行快开发慢，C、C++、Go、Rust)<br><strong>解释型</strong> ：解释型语言会通过<strong>解释器一句一句</strong>的将代码解释为机器码后再执行。(执行慢开发快，Python、JavaScript、PHP)<br>Java 程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。既具有编译型语言的特征，也具有解释型语言的特征。<br><img src="https://img-blog.csdnimg.cn/16732eb6e12e47478c3e22bf40dc0e8d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_12,color_FFFFFF,t_70,g_se,x_16" alt="编译器与解释器"><br>扩展：<strong>即时编译</strong>：混合了编译语言与解释型语言的优点。先把程序源代码编译成字节码，到执行期时，再将字节码直译，之后执行</p>
<h2 id="5-Oracle-JDK-vs-OpenJDK"><a href="#5-Oracle-JDK-vs-OpenJDK" class="headerlink" title="5. Oracle JDK vs OpenJDK"></a>5. Oracle JDK vs OpenJDK</h2><ol>
<li>发布时间：Oracle 6个月，open 3个月。</li>
<li>开源：Oracle 不完全开源，是open(开源)的一个实现</li>
<li>稳定：Oracle 更稳定。二者代码几乎相同。</li>
<li>响应性和JVM性能：Oracle 更好</li>
<li>获取：Oracle 不提供新版本支持</li>
<li>协议：Oracle BCL&#x2F;OTN协议（商用），open GPL v2协议<h2 id="6-Java-和-C-的区别"><a href="#6-Java-和-C-的区别" class="headerlink" title="6. Java 和 C++ 的区别?"></a>6. Java 和 C++ 的区别?</h2></li>
<li>Java <strong>不提供指针</strong>来直接访问内存，程序<strong>内存更加安全</strong></li>
<li>Java 的<strong>类是单继承</strong>的，C++ 支持多重继承；但是Java<strong>接口可以多继承</strong>。</li>
<li>Java 有<strong>自动内存管理垃圾回收机制</strong>(GC)，不需要程序员手动释放无用内存。</li>
<li>C ++同时支持方法重载和操作符重载，但是 Java 只支持<strong>方法重载</strong>（操作符重载增加了复杂性）<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="1-字符型常量和字符串常量的区别"><a href="#1-字符型常量和字符串常量的区别" class="headerlink" title="1. 字符型常量和字符串常量的区别?"></a>1. 字符型常量和字符串常量的区别?</h2></li>
<li><strong>形式</strong>：字符常量 <strong>单引号</strong> 一个字符，字符串常量 <strong>双引号</strong> 多字符</li>
<li><strong>含义</strong>：字符常量相当于一个<strong>整型值</strong>( ASCII 值)，可以参加表达式运算；字符串常量代表一个<strong>地址值</strong>(该字符串在内存中存放位置)。</li>
<li><strong>占内存大小</strong>：字符常量(char)只占 <strong>2 个字节</strong>; 字符串常量占若干个字节。<h2 id="2-注释有哪几种形式？"><a href="#2-注释有哪几种形式？" class="headerlink" title="2. 注释有哪几种形式？"></a>2. 注释有哪几种形式？</h2>单行注释；多行注释；文档注释。<h2 id="3-标识符和关键字的区别是什么？"><a href="#3-标识符和关键字的区别是什么？" class="headerlink" title="3. 标识符和关键字的区别是什么？"></a>3. 标识符和关键字的区别是什么？</h2><strong>标识符</strong>：为程序、类、变量、方法等取的名字。<br><strong>关键字</strong>：被赋予特殊含义的标识符。Java 语言已经赋予了其特殊的含义，只能用于特定的地方。<table>
<thead>
<tr>
<th>分类</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>访问控制</td>
<td>private  protected  public</td>
</tr>
<tr>
<td>类，方法和变量修饰符</td>
<td>abstract	class	extends	final	implements	interface	native new	static	strictfp	synchronized	transient	volatile	enum</td>
</tr>
<tr>
<td>程序控制</td>
<td>break	continue	return	do	while	if	elsefor	instanceof	switch	case	default	assert</td>
</tr>
<tr>
<td>错误处理</td>
<td>try	catch	throw	throws	finally</td>
</tr>
<tr>
<td>包相关</td>
<td>import	package</td>
</tr>
<tr>
<td>基本类型</td>
<td>boolean	byte	char	double	float	int	long short</td>
</tr>
<tr>
<td>变量引用</td>
<td>super	this	void</td>
</tr>
<tr>
<td>保留字</td>
<td>goto	const</td>
</tr>
</tbody></table>
<h2 id="4-自增自减运算符"><a href="#4-自增自减运算符" class="headerlink" title="4. 自增自减运算符"></a>4. 自增自减运算符</h2>当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。<h2 id="5-continue、break-和-return-的区别是什么？"><a href="#5-continue、break-和-return-的区别是什么？" class="headerlink" title="5. continue、break 和 return 的区别是什么？"></a>5. continue、break 和 return 的区别是什么？</h2><code>continue</code>：指跳出<strong>当前循环</strong>，继续下一次循环<br><code>break</code>：指跳出<strong>整个循环体</strong>，继续执行循环下面的语句<br><code>return</code>：用于跳出<strong>所在方法</strong>，结束该方法的运行。</li>
<li><code>return;</code>  直接使用 return 结束方法执行，用于没有返回值函数的方法</li>
<li><code>return value</code>  return 一个特定值，用于有返回值函数的方法<h2 id="6-方法：什么是方法的返回值-方法有哪几种类型？"><a href="#6-方法：什么是方法的返回值-方法有哪几种类型？" class="headerlink" title="6. 方法：什么是方法的返回值?方法有哪几种类型？"></a>6. 方法：什么是方法的返回值?方法有哪几种类型？</h2><strong>方法的返回值</strong>：获取到的某个方法体中的代码<strong>执行后产生的结果</strong>！<br>1.无参数无返回值的方法；2.有参数无返回值的方法<br>3.有返回值无参数的方法；4.有返回值有参数的方法<h2 id="7-静态方法为什么不能调用非静态成员-结合-JVM-的相关知识"><a href="#7-静态方法为什么不能调用非静态成员-结合-JVM-的相关知识" class="headerlink" title="7. 静态方法为什么不能调用非静态成员?(结合 JVM 的相关知识)"></a>7. 静态方法为什么不能调用非静态成员?(结合 JVM 的相关知识)</h2></li>
<li>静态方法是<strong>属于类</strong>的，在<strong>类加载的时候就会分配内存</strong>，可以通过类名直接访问。而非静态成员属于<strong>实例对象</strong>，只有在<strong>对象实例化之后才存在</strong>，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。<h2 id="8-静态方法和实例方法有何不同？"><a href="#8-静态方法和实例方法有何不同？" class="headerlink" title="8. 静态方法和实例方法有何不同？"></a>8. 静态方法和实例方法有何不同？</h2></li>
<li><strong>调用方式</strong>：在外部调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用<code>对象.方法名</code>的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</li>
<li><strong>访问类成员是否存在限制</strong>：<code>静态方法在访问本类的成员时，只允许访问静态成员</code>（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。<h2 id="9-重载和重写的区别"><a href="#9-重载和重写的区别" class="headerlink" title="9. 重载和重写的区别"></a>9. 重载和重写的区别</h2><strong>重载</strong>：同一个类中多个<strong>同名方法</strong>根据<strong>不同的传参</strong>来执行<strong>不同的逻辑</strong>处理。<br>（发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。）**(编译期)**<br><strong>重写</strong>：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。（<strong>运行期</strong>）<br>方法的重写要遵循“<strong>两同两小一大</strong>”：</li>
<li>两同：<code>方法名</code>、<code>形参列表</code></li>
<li>两小：子类方法<code>返回值类型</code>、<code>声明抛出的异常类</code>  比父类方法更小或相等</li>
<li>一大：子类方法的<code>访问权限</code>应比父类方法的访问权限更大或相等<h2 id="10-x3D-x3D-和-equals-的区别"><a href="#10-x3D-x3D-和-equals-的区别" class="headerlink" title="10. &#x3D;&#x3D; 和 equals() 的区别"></a>10. &#x3D;&#x3D; 和 equals() 的区别</h2></li>
<li><strong>基本数据类型</strong>，<code>==</code> 比较的是<strong>值</strong>。<br><strong>引用数据类型</strong>，<code>== </code>比较的是对象的<strong>内存地址</strong>。</li>
<li><code> equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<br>(<code>equals()</code>未重写等价与<code>==</code>，重写后如上）</li>
<li><code>Java 只有值传递</code>，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。<h2 id="11-hashCode-与-equals"><a href="#11-hashCode-与-equals" class="headerlink" title="11. hashCode() 与 equals()"></a>11. hashCode() 与 equals()</h2></li>
<li>hashCode() 有什么用？<br>获取哈希码（int 整数），也称为散列码。哈希码作用是确定该对象在哈希表中的<strong>索引位置</strong>。</li>
<li>为什么要有 hashCode？<br>对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode值</code> 来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode 值</code>作比较。<br>如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。<br>如果发现有相同 <code>hashCode 值</code>的对象，这时会调用 <code>equals() 方法</code>来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。<br><code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等</li>
<li>那为什么 JDK 还要同时提供这两个方法呢？<br>同样的 <code>hashCode</code> 有多个对象，它会继续使用 <code>equals()</code> 来判断是否真的相同。也就是说 <code>hashCode</code> 帮助我们大大缩小了查找成本。</li>
<li>那为什么不只提供 hashCode() 方法呢？<br>两个对象的<code>hashCode 值</code>相等并不代表两个对象就相等</li>
<li>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？<br>哈希算法也许刚好会让多个对象传回相同的哈希值(哈希碰撞)</li>
<li>为什么重写 <code>equals()</code> 时必须重写 <code>hashCode()</code> 方法？<br>两个相等的对象的 hashCode 值必须是相等<br><strong>总结</strong>：</li>
<li>如果两个对象的<code>hashCode 值</code>相等，那这两个对象不一定相等（哈希碰撞）。</li>
<li>如果两个对象的<code>hashCode 值</code>相等并且equals()方法也返回 true，我们才认为这两个对象相等。</li>
<li>如果两个对象的<code>hashCode 值</code>不相等，我们就可以直接认为这两个对象不相等。<h2 id="12-什么是可变长参数？"><a href="#12-什么是可变长参数？" class="headerlink" title="12. 什么是可变长参数？"></a>12. 什么是可变长参数？</h2>允许在调用方法时传入不定长度的参数。<br>遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？<br><strong>会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。</strong><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><h2 id="1-Java-中的8种基本数据类型了解么"><a href="#1-Java-中的8种基本数据类型了解么" class="headerlink" title="1. Java 中的8种基本数据类型了解么?"></a>1. Java 中的8种基本数据类型了解么?</h2></li>
<li>6 种<strong>数字类型</strong>：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>(4 种<strong>整数型)<strong>、<code>float</code>、<code>double</code>(2 种浮</strong>点型</strong>)</li>
<li>1 种<strong>字符类型</strong>：<code>char</code></li>
<li>1 种<strong>布尔型</strong>：<code>boolean</code></li>
</ol>
<p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code><br>包装类型不赋值就是 <code>Null</code> ，而基本类型有默认值且不是 <code>Null</code><br>(基本数据类型直接存放在 Java 虚拟机栈中的<strong>局部变量表</strong>中，而包装类型属于对象类型，我们知道<strong>对象实例都存在于堆</strong>中。相比于对象类型， 基本数据类型占用的空间非常小。)<br><img src="https://img-blog.csdnimg.cn/3519514622cb465394087dc5a3e87067.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_17,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h2 id="2-包装类型的常量池技术了解么？"><a href="#2-包装类型的常量池技术了解么？" class="headerlink" title="2. 包装类型的常量池技术了解么？"></a>2. 包装类型的常量池技术了解么？</h2><p>Java 基本类型的包装类的大部分都实现了<strong>常量池技术</strong>。<br><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 [-128，127] 的相应类型的缓存数据，<code>Character</code> 创建了数值在 [0,127] 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。浮点型没有实现常量池技术。</p>
<ol>
<li>所有整型包装类对象之间值的比较，全部使用 equals 方法比较<br><img src="https://img-blog.csdnimg.cn/ae16a30e0f4744f58a3bc1551ff94dbb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="3-自动装箱与拆箱了解吗？原理是什么？"><a href="#3-自动装箱与拆箱了解吗？原理是什么？" class="headerlink" title="3. 自动装箱与拆箱了解吗？原理是什么？"></a>3. 自动装箱与拆箱了解吗？原理是什么？</h2></li>
<li>什么是自动拆装箱？<br><strong>装箱</strong>：将<strong>基本类型</strong>用对应的<strong>引用类型</strong>包装起来；<br><strong>拆箱</strong>：将<strong>包装类型</strong>转换为<strong>基本数据类型</strong>；</li>
<li>原理：从字节码中，我们发现<strong>装箱</strong>其实就是调用了 包装类的<code>valueOf()方法</code>，拆箱其实就是调用了 <code>xxxValue()</code>方法。<br><code>Integer i = 10</code> 等价于 <code>Integer i = Integer.valueOf(10)</code><br><code>int n = i</code> 等价于 <code>int n = i.intValue()</code><br>频繁拆装箱的话，也会严重影响系统的性能。尽量避免不必要的拆装箱操作。</li>
</ol>
<h1 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h1><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p>区别在于<strong>解决问题的方式</strong>不同。<br><strong>面向过程</strong>：把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题<br><strong>面向对象</strong>：先抽象出对象，然后用对象执行方法的方式解决问题。<br>面向对象开发的程序一般更易<strong>维护</strong>、易<strong>复用</strong>、易<strong>扩展</strong></p>
<h2 id="2-成员变量与局部变量的区别有哪些？"><a href="#2-成员变量与局部变量的区别有哪些？" class="headerlink" title="2. 成员变量与局部变量的区别有哪些？"></a>2. 成员变量与局部变量的区别有哪些？</h2><ul>
<li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 static 修饰的，那么这个成员变量是属于类的，如果没有使用 static 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li>
<li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值<h2 id="3-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#3-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="3. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>3. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。<br>一个对象引用可以指向 0 个或 1 个对象；一个对象可以有 n 个引用指向它。<h2 id="4-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#4-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="4. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>4. 对象的相等与指向他们的引用相等,两者有什么不同?</h2></li>
<li>对象的相等一般比较的是内存中存放的<strong>内容</strong>是否相等。</li>
<li>引用相等一般比较的是他们指向的<strong>内存地址</strong>是否相等。<h2 id="5-一个类的构造方法的作用是什么"><a href="#5-一个类的构造方法的作用是什么" class="headerlink" title="5. 一个类的构造方法的作用是什么?"></a>5. 一个类的构造方法的作用是什么?</h2>构造方法是一种特殊的方法，主要作用是<strong>完成对象的初始化工作</strong>。<h2 id="6-如果一个类没有声明构造方法，该程序能正确执行吗"><a href="#6-如果一个类没有声明构造方法，该程序能正确执行吗" class="headerlink" title="6. 如果一个类没有声明构造方法，该程序能正确执行吗?"></a>6. 如果一个类没有声明构造方法，该程序能正确执行吗?</h2>可以。一个类没有声明构造方法，也会有<strong>默认的不带参数的构造方法</strong>。<br>如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了。<br>创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来。</li>
</ul>
<h2 id="7-构造方法有哪些特点？是否可被-override"><a href="#7-构造方法有哪些特点？是否可被-override" class="headerlink" title="7. 构造方法有哪些特点？是否可被 override?"></a>7. 构造方法有哪些特点？是否可被 override?</h2><p>构造方法特点如下：</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<p>构造方法<strong>不能被 override（重写）</strong>,但是<strong>可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="8-面向对象三大特征"><a href="#8-面向对象三大特征" class="headerlink" title="8. 面向对象三大特征"></a>8. 面向对象三大特征</h2><ol>
<li><strong>封装</strong>。把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</li>
<li><strong>继承</strong>。 使用<strong>已存在的类</strong>的定义作为<strong>基础</strong>建立<strong>新类</strong>的技术，新类的定义可以<strong>增加新的数据或新的功能</strong>，也可以用父类的功能，但不能选择性地继承父类。<br>2.1 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。<br>2.2 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>2.3 子类可以用自己的方式实现父类的方法。</li>
<li><strong>多态</strong>。表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。<br>3.1 对象类型和引用类型之间具有<strong>继承</strong>（类）&#x2F;实现（接口）的关系；<br>3.2 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；<br>3.3 多态不能调用“只在子类存在但在父类不存在”的方法；<br>3.4 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法<h2 id="9-接口和抽象类有什么共同点和区别？"><a href="#9-接口和抽象类有什么共同点和区别？" class="headerlink" title="9. 接口和抽象类有什么共同点和区别？"></a>9. 接口和抽象类有什么共同点和区别？</h2><strong>共同点</strong>：</li>
<li>都不能被实例化。</li>
<li>都可以包含抽象方法。</li>
<li>都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。</li>
</ol>
<p><strong>区别</strong>：</p>
<ol>
<li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li>
<li>一个类只能继承一个类，但是可以实现多个接口。</li>
<li>接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值.<h2 id="10-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#10-深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="10. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>10. 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h2><strong>深拷贝</strong>：深拷贝会完全<strong>复制整个对象</strong>，包括这个对象所包含的内部对象。<br><strong>浅拷贝</strong>：在堆上创建一个<strong>新对象</strong>。原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址。<br><strong>引用拷贝</strong>：两个不同的引用指向<strong>同一个对象</strong>。<br><img src="https://img-blog.csdnimg.cn/img_convert/5089a086b18f8e3cb26ed513c79f1edd.png" alt="拷贝"><h1 id="Java常见对象"><a href="#Java常见对象" class="headerlink" title="Java常见对象"></a>Java常见对象</h1><h2 id="1-Object-类的常见方法有哪些？"><a href="#1-Object-类的常见方法有哪些？" class="headerlink" title="1. Object 类的常见方法有哪些？"></a>1. Object 类的常见方法有哪些？</h2>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()</span><br><span class="line"><span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span></span><br><span class="line"><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span><br><span class="line"><span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line"><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span></span><br><span class="line"><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span><br><span class="line"><span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line"><span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>
<h2 id="2-String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的"><a href="#2-String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的" class="headerlink" title="2. String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?"></a>2. String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h3><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</li>
<li>保存字符串的数组被 <code>final</code> <strong>修饰且为私有的</strong>，并且<code>String</code> 类<strong>没有提供&#x2F;暴露</strong>修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其<strong>不能被继承</strong>，进而避免了子类破坏 <code>String</code> 不可变。<br>(final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象)</li>
</ol>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><code>String</code> 中的<strong>对象是不可变</strong>的，也就可以理解为常量，<strong>线程安全</strong>。<br><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法<strong>加了同步锁</strong>，所以是<strong>线程安全</strong>的。<br><code>StringBuilder</code> 并<strong>没有</strong>对方法进行<strong>加同步锁</strong>，所以是非线程安全的。<br>（<code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。）</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p><code>String</code>：每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<br><code>StringBuffer</code>：每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。<br><code>StringBuilder</code>：相比<code>StringBuffer</code>获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>String</code>：操作<strong>少量</strong>的数据<br><code>StringBuffer</code>：<strong>多线程</strong>操作字符串缓冲区下操作大量数据	<br><code>StringBuilder</code>：<strong>单线程</strong>操作字符串缓冲区下操作大量数据</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="1-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？"><a href="#1-Java-泛型了解么？什么是类型擦除？介绍一下常用的通配符？" class="headerlink" title="1. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？"></a>1. Java 泛型了解么？什么是类型擦除？介绍一下常用的通配符？</h2><p><strong>泛型</strong>：泛型提供了编译时<strong>类型安全检测</strong>机制，该机制允许程序员在<strong>编译时检测到非法的类型</strong>。<br>泛型的本质是参数化类型，所操作的数据类型被指定为一个参数。<br><strong>类型擦除</strong>：Java 的泛型是<strong>伪泛型</strong>，在<strong>运行期间</strong>，<strong>所有的泛型信息都会被擦掉</strong>。<br>泛型一般有三种使用方式：<strong>泛型类、泛型接口、泛型方法</strong>。<br><strong>通配符</strong>：T，E，K，V，？</p>
<ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的 Key Value</li>
<li>E (element) 代表 Element<br><strong>你的项目中哪里用到了泛型？</strong></li>
<li>可用于定义通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 T 可根据具体的返回类型动态指定结果的数据类型</li>
<li>定义 Excel 处理类 <code>ExcelUtil&lt;T&gt;</code> 用于动态指定 Excel 导出的数据类型</li>
<li>用于构建集合工具类。参考 <code>Collections</code> 中的 sort, binarySearch 方法<br>……<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1-何为反射"><a href="#1-何为反射" class="headerlink" title="1. 何为反射"></a>1. 何为反射</h2>反射被称为框架的灵魂，赋予了我们在运行时<strong>分析类以及执行类中方法的能力</strong>。<br>通过反射你可以<strong>获取任意一个类的所有属性和方法</strong>，<strong>还可以调用这些方法和属性</strong>。<h2 id="2-反射机制优缺点"><a href="#2-反射机制优缺点" class="headerlink" title="2. 反射机制优缺点"></a>2. 反射机制优缺点</h2></li>
<li><strong>优点</strong> ： 可以让咱们的<strong>代码更加灵活</strong>、为各种框架提供<strong>开箱即用</strong>的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在<strong>运行时有了分析操作类的能力</strong>，这同样也增加了<strong>安全问题</strong>。比如可以<strong>无视泛型参数的安全检查</strong>（泛型参数的安全检查发生在编译时）。另外，反射的<strong>性能也稍差</strong>点，不过，对于框架来说实际是影响不大的。<h2 id="3-反射的应用场景"><a href="#3-反射的应用场景" class="headerlink" title="3. 反射的应用场景"></a>3. 反射的应用场景</h2><code>Spring/Spring Boot</code>、<code>MyBatis</code> 等等框架中都大量使用了反射机制。<br>这些框架中也大量使用了<strong>动态代理</strong>，而动态代理的<strong>实现依赖反射</strong>。<h2 id="4-获取-Class-对象的四种方式"><a href="#4-获取-Class-对象的四种方式" class="headerlink" title="4. 获取 Class 对象的四种方式"></a>4. 获取 Class 对象的四种方式</h2>如果我们动态获取到这些信息，我们需要依靠 Class 对象。Class 类对象将一个类的方法、变量等信息告诉运行的程序。Java 提供了四种方式获取 Class 对象：</li>
</ul>
<ol>
<li>知道<strong>具体类</strong>的情况下可以使用：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass</span> <span class="operator">=</span> TargetObject.class;</span><br></pre></td></tr></table></figure>
不知道具体类的，基本都是通过遍历包下面的类来获取 Class 对象，通过此方式获取 Class 对象不会进行初始化</li>
<li>通过 <code>Class.forName()</code>传入类的全路径获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>通过<strong>对象实例</strong><code>instance.getClass()</code>获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">TargetObject</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TargetObject</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">alunbarClass2</span> <span class="operator">=</span> o.getClass();</span><br></pre></td></tr></table></figure></li>
<li>通过<strong>类加载器</strong><code>xxxClassLoader.loadClass()</code>传入类路径获取：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.loadClass(<span class="string">&quot;cn.javaguide.TargetObject&quot;</span>);</span><br></pre></td></tr></table></figure>
通过类加载器获取 Class 对象不会进行初始化，意味着不进行包括初始化等一系列步骤，静态代码块和静态对象不会得到执行<h2 id="5-反射的一些基本操作"><a href="#5-反射的一些基本操作" class="headerlink" title="5. 反射的一些基本操作"></a>5. 反射的一些基本操作</h2></li>
<li>创建一个我们要使用反射操作的类 TargetObject</li>
<li>使用反射操作这个类的方法以及参数<h1 id="注解Annontation"><a href="#注解Annontation" class="headerlink" title="注解Annontation"></a>注解<code>Annontation</code></h1><strong>注解</strong>：本质是一个继承了<code>Annotation</code> 的<strong>特殊接口</strong><br>注解只有被解析之后才会生效，常见的解析方法有两种：</li>
</ol>
<ul>
<li><strong>编译期直接扫描</strong> ：编译器在<strong>编译 Java 代码的时候</strong>扫描对应的注解并处理。比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</li>
<li><strong>运行期通过反射处理</strong>：像<strong>框架</strong>中自带的注解(比如 <code>Spring</code> 框架的 <code>@Value</code> 、<code>@Component</code>)都是通过反射来进行处理的。<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><strong>Java 异常类层次结构图概览 ：</strong><br><img src="https://img-blog.csdnimg.cn/1655c39e8eaf44029950d71d82bc9b3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="1-Exception-和-Error-有什么区别？"><a href="#1-Exception-和-Error-有什么区别？" class="headerlink" title="1. Exception 和 Error 有什么区别？"></a>1. Exception 和 Error 有什么区别？</h2>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable 类</code>。<code>Throwable 类</code>有两个重要的子类：<br><code>Exception</code>：<strong>程序本身可以处理的异常</strong>，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <code>Checked Exception</code> (受检查异常，必须处理) 和 <code>Unchecked Exception</code> (不受检查异常，可以不处理)。<br><code>Error</code>：<code>Error</code>属于<strong>程序无法处理的错误</strong> ，我们没办法通过<code>catch</code>来进行捕获不建议通过<code>catch</code>捕获 。例如Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。<h2 id="2-Checked-Exception-和-Unchecked-Exception-有什么区别？"><a href="#2-Checked-Exception-和-Unchecked-Exception-有什么区别？" class="headerlink" title="2. Checked Exception 和 Unchecked Exception 有什么区别？"></a>2. Checked Exception 和 Unchecked Exception 有什么区别？</h2> <strong><code>Checked Exception</code> (受检查异常，必须处理)<strong>：Java 代码在编译过程中，如果受检查异常没有被 <strong>catch&#x2F;throw 处理</strong>的话，就没办法通过编译 。<br><strong><code>Unchecked Exception</code> (不受检查异常，可以不处理)<strong>：Java 代码在编译过程中 ，我们即使</strong>不处理</strong>不受检查异常</strong>也可以正常通过编译</strong>。<h2 id="3-Throwable-类常用方法有哪些？"><a href="#3-Throwable-类常用方法有哪些？" class="headerlink" title="3. Throwable 类常用方法有哪些？"></a>3. Throwable 类常用方法有哪些？</h2></li>
<li><code>String getMessage()</code>：返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>：返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</li>
<li><code>void printStackTrace()</code>：在控制台上打印 Throwable 对象封装的异常信息<h2 id="4-try-catch-finally-如何使用？"><a href="#4-try-catch-finally-如何使用？" class="headerlink" title="4. try-catch-finally 如何使用？"></a>4. try-catch-finally 如何使用？</h2><code>try</code>块： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个<code>finally</code> 块。<br><code>catch</code>块： 用于处理 <code>try</code> 捕获到的异常。<br><code>finally</code> 块： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，finally 语句块将在方法返回之前被执行。<br><strong>注意</strong>：<strong>不要在 finally 语句块中使用 return</strong>! 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。<h2 id="5-finally-中的代码一定会执行吗？"><a href="#5-finally-中的代码一定会执行吗？" class="headerlink" title="5. finally 中的代码一定会执行吗？"></a>5. finally 中的代码一定会执行吗？</h2>不一定的！在某些情况下，<code>finally</code> 中的代码不会被执行。</li>
</ul>
<ol>
<li>比如说 <code>finally</code> 之前虚拟机被终止运行</li>
<li>程序所在的线程死亡</li>
<li>关闭 CPU<h1 id="I-x2F-O"><a href="#I-x2F-O" class="headerlink" title="I&#x2F;O"></a>I&#x2F;O</h1><h2 id="1-什么是序列化？什么是反序列化？"><a href="#1-什么是序列化？什么是反序列化？" class="headerlink" title="1. 什么是序列化？什么是反序列化？"></a>1. 什么是序列化？什么是反序列化？</h2></li>
</ol>
<ul>
<li><strong>序列化</strong>： 将<strong>数据结构或对象</strong>转换成<strong>二进制字节流</strong>的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的<strong>二进制字节流</strong>转换成<strong>数据结构或者对象</strong>的过程<br><strong>序列化的主要目的</strong>：通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中<br>对于 Java 面向对象编程语言，<strong>序列化的都是对象</strong>（Object），也就是实例化后的类(Class)，<br> C++这种半面向对象的语言中，struct(结构体)定义的是<strong>数据结构类型</strong>，而 class 对应的是对象类型。<h2 id="2-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#2-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="2. Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>2. Java 序列化中如果有些字段不想进行序列化，怎么办？</h2>使用 <code>transient</code> 关键字修饰。<br><strong><code>transient</code> 关键字的作用是</strong>：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。<h2 id="3-获取用键盘输入常用的两种方法"><a href="#3-获取用键盘输入常用的两种方法" class="headerlink" title="3. 获取用键盘输入常用的两种方法"></a>3. 获取用键盘输入常用的两种方法</h2></li>
</ul>
<ol>
<li>通过 <code>Scanner</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></li>
<li>通过 <code>BufferedReader</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>
<h2 id="4-Java-中-IO-流分为几种"><a href="#4-Java-中-IO-流分为几种" class="headerlink" title="4. Java 中 IO 流分为几种?"></a>4. Java 中 IO 流分为几种?</h2></li>
</ol>
<ul>
<li>按照流的<strong>流向</strong>：输入流    输出流</li>
<li>按照操作<strong>单元</strong>：字节流    字符流</li>
<li>按照流的<strong>角色</strong>：节点流    处理流<h2 id="5-既然有了字节流-为什么还要有字符流"><a href="#5-既然有了字节流-为什么还要有字符流" class="headerlink" title="5. 既然有了字节流,为什么还要有字符流?"></a>5. 既然有了字节流,为什么还要有字符流?</h2><strong>本质</strong>：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I&#x2F;O 流操作要分为字节流操作和字符流操作呢？<br><strong>字符流</strong>是由 Java 虚拟机将<strong>字节转换得到</strong>的，这个过程<strong>① 非常耗时</strong>，<strong>② 不知道编码类型易乱码问题</strong>。<br>所以， I&#x2F;O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。<br><strong>音频文件、图片</strong>等媒体文件用字节流比较好。<br><strong>涉及到字符</strong>的话使用字符流比较好。<h1 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h1><h2 id="1-形参-amp-实参"><a href="#1-形参-amp-实参" class="headerlink" title="1. 形参&amp;实参"></a>1. 形参&amp;实参</h2>方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为：</li>
<li><strong>实参（实际参数）</strong>：用于<strong>传递</strong>给函数&#x2F;方法的参数，必须有确定的值。</li>
<li><strong>形参（形式参数）</strong>：用于<strong>定义</strong>函数&#x2F;方法，接收实参，不需要有确定的值<h2 id="2-值传递-amp-引用传递"><a href="#2-值传递-amp-引用传递" class="headerlink" title="2. 值传递&amp;引用传递"></a>2. 值传递&amp;引用传递</h2>程序设计语言将<strong>实参传递</strong>给方法（或函数）的方式分为两种：<br><strong>值传递</strong>：方法接收的是<strong>实参值</strong>的拷贝，会<strong>创建副本</strong>。<br><strong>引用传递</strong>：方法接收的直接是实参所引用的对象在<strong>堆中的地址</strong>，<strong>不会创建副本</strong>，对形参的修改将影响到实参。<br>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2>Java 中将<strong>实参传递给方法</strong>（或函数）的方式是 <strong>值传递</strong> ：<br>如果参数是<strong>基本类型</strong>的话：传递的就是<strong>基本类型的字面量值</strong>的拷贝，会创建副本。<br>如果参数是<strong>引用类型</strong>：传递的就是<strong>实参所引用的对象在堆中地址值</strong>的拷贝，同样也会创建副本。<h1 id="Java-代理模式详解"><a href="#Java-代理模式详解" class="headerlink" title="Java 代理模式详解"></a>Java 代理模式详解</h1><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2>使用<strong>代理对象</strong>来代替对真实对象(real object)的访问，到达在<strong>不修改原目标对象</strong>的前提下，<strong>扩展</strong>目标对象的额外的<strong>功能</strong>操作。（<strong>静态</strong>代理  <strong>动态</strong>代理）<h2 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2. 静态代理"></a>2. 静态代理</h2></li>
</ul>
<ol>
<li><strong>实现和应用角度</strong>：对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象<strong>都要进行修改</strong>）且麻烦(需要对每个目标类<strong>都单独写一个代理类</strong>)。 （现实几乎看不到）</li>
<li><strong>JVM 层面</strong>：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 <code>.class</code> 文件。</li>
<li>实现步骤：<br>3.1 <strong>定义</strong>一个<strong>接口</strong>及其<strong>实现类</strong>；<br>3.2 <strong>创建</strong>一个<strong>代理类</strong>同样<strong>实现这个接口</strong><br>3.3 将目标对象<strong>注入</strong>进代理类，然后在<strong>代理类</strong>的对应方法<strong>调用目标类</strong>中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。<h2 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h2></li>
<li><strong>实现和应用角度</strong>：更加灵活。不需要针对每个目标类都单独创建一个代理类，也不需要必须实现接口，可以直接代理实现类( CGLIB 动态代理机制)。</li>
<li><strong>JVM 层面</strong>：动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。<h2 id="3-1-JDK-动态代理机制"><a href="#3-1-JDK-动态代理机制" class="headerlink" title="3.1 JDK 动态代理机制"></a>3.1 JDK 动态代理机制</h2><code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。<br><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。<br>这个方法一共有 3 个参数：</li>
<li><code>loader</code>：类加载器，用于加载代理对象。</li>
<li><code>interfaces</code>：被代理类实现的一些接口；</li>
<li><code>h</code>：实现了 InvocationHandler 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。<br> <code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><code>proxy</code> :动态生成的代理类</li>
<li><code>method</code> : 与代理类对象调用的方法相对应</li>
<li><code>args</code> : 当前 method 方法的参数</li>
</ol>
<p><strong>总结</strong>：通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
<ol>
<li>JDK 动态代理类使用步骤<br>1.1 定义一个接口及其实现类；<br>1.2 自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；<br>1.3 通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象</li>
</ol>
<h2 id="3-CGLIB-动态代理机制"><a href="#3-CGLIB-动态代理机制" class="headerlink" title="3. CGLIB 动态代理机制"></a>3. CGLIB 动态代理机制</h2><p>JDK 动态代理最致命的问题：<strong>只能代理实现了接口的类</strong>。（CGLIB动态代理机制）</p>
<ul>
<li><strong>CGLIB</strong>(Code Generation Library)是一个基于ASM的<strong>字节码生成库</strong>，在<strong>运行时</strong>对字节码进行<strong>修改和动态生成</strong>。</li>
<li><strong>CGLIB</strong> 通过<strong>继承方式</strong>实现代理。</li>
<li><strong>Spring</strong> 中的 <strong>AOP</strong> 模块中：如果目标对象<strong>实现了接口</strong>，则默认采用 <strong>JDK 动态代理</strong>，<strong>否则采用 CGLIB</strong> 动态代理。</li>
<li>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。<br>（需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于<strong>拦截增强被代理类的方法</strong>。）<br>（通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。）<h2 id="4-CGLIB-动态代理类使用步骤"><a href="#4-CGLIB-动态代理类使用步骤" class="headerlink" title="4. CGLIB 动态代理类使用步骤"></a>4. CGLIB 动态代理类使用步骤</h2></li>
</ul>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；<h2 id="5-静态代理和动态代理的对比"><a href="#5-静态代理和动态代理的对比" class="headerlink" title="5. 静态代理和动态代理的对比"></a>5. 静态代理和动态代理的对比</h2></li>
<li><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong>：静态代理在<strong>编译时</strong>就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在<strong>运行时</strong>动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
<h1 id="I-x2F-O（Input-x2F-Outpu）-即输入／输出"><a href="#I-x2F-O（Input-x2F-Outpu）-即输入／输出" class="headerlink" title="I&#x2F;O（Input&#x2F;Outpu） 即输入／输出"></a>I&#x2F;O（Input&#x2F;Outpu） 即输入／输出</h1><p><strong>冯.诺依曼</strong>结构，计算机结构分为 5 大部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong><br> I&#x2F;O 描述了：<strong>计算机系统</strong>与<strong>外部设备</strong>之间通信的过程。<br><img src="https://img-blog.csdnimg.cn/830650cf4e0a417abad383dfe36ab280.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>为了<strong>保证操作系统的稳定性和安全性</strong>，一个进程的地址空间划分为 <strong>用户空间</strong>（User space） 和 <strong>内核空间</strong>（Kernel space ）。<br>从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（<strong>系统调用</strong>），操作系统负责的<strong>内核执行具体的 IO 操作</strong>。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的<strong>内核完成</strong>的。</p>
<ol>
<li>内核等待 I&#x2F;O 设备准备好数据。</li>
<li>内核将数据从内核空间拷贝到用户空间。<h2 id="1-有哪些常见的-IO-模型"><a href="#1-有哪些常见的-IO-模型" class="headerlink" title="1. 有哪些常见的 IO 模型?"></a>1. 有哪些常见的 IO 模型?</h2>UNIX 系统下，IO 模型一共有 5 种： <strong>同步阻塞</strong> I&#x2F;O、<strong>同步非阻塞</strong> I&#x2F;O、I&#x2F;O <strong>多路复用</strong>、<strong>信号驱动</strong> I&#x2F;O 和<strong>异步</strong> I&#x2F;O。<h2 id="2-BIO-Blocking-I-x2F-O-（同步阻塞I-x2F-O模型）"><a href="#2-BIO-Blocking-I-x2F-O-（同步阻塞I-x2F-O模型）" class="headerlink" title="2. BIO (Blocking I&#x2F;O)（同步阻塞I&#x2F;O模型）"></a>2. BIO (Blocking I&#x2F;O)（同步阻塞I&#x2F;O模型）</h2><img src="https://img-blog.csdnimg.cn/efe6c639db6a4ded945075ea3bd26e66.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="3-NIO-Non-blocking-x2F-New-I-x2F-O-（-I-x2F-O-多路复用模型）"><a href="#3-NIO-Non-blocking-x2F-New-I-x2F-O-（-I-x2F-O-多路复用模型）" class="headerlink" title="3. NIO (Non-blocking&#x2F;New I&#x2F;O)（ I&#x2F;O 多路复用模型）"></a>3. NIO (Non-blocking&#x2F;New I&#x2F;O)（ I&#x2F;O 多路复用模型）</h2><img src="https://img-blog.csdnimg.cn/39d38f6393124b0e88c65235c5c2897f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据</strong>是否已经准备好的过程是十分<strong>消耗CPU</strong> 资源的。<br><img src="https://img-blog.csdnimg.cn/f1afbf2ae8a049de8da19640524ce15d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_14,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。<h2 id="4-AIO-Asynchronous-I-x2F-O-（异步I-x2F-O模型）"><a href="#4-AIO-Asynchronous-I-x2F-O-（异步I-x2F-O模型）" class="headerlink" title="4. AIO (Asynchronous I&#x2F;O)（异步I&#x2F;O模型）"></a>4. AIO (Asynchronous I&#x2F;O)（异步I&#x2F;O模型）</h2>基于<strong>事件和回调</strong>机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当<strong>后台处理完</strong>成，操作系统<strong>会通知</strong>相应的线程进行<strong>后续</strong>的操作。<br><img src="https://img-blog.csdnimg.cn/daaa57e82acf4a55bc1703d428b3f085.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5bc33936cd43453da9d882a5fd0e975c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt=" Java 中的 BIO、NIO、AIO"><h2 id="BigDecimal-详解"><a href="#BigDecimal-详解" class="headerlink" title="BigDecimal 详解"></a>BigDecimal 详解</h2><h2 id="1-BigDecimal-介绍"><a href="#1-BigDecimal-介绍" class="headerlink" title="1. BigDecimal 介绍"></a>1. BigDecimal 介绍</h2><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。<h2 id="2-为什么浮点数-float-或-double-运算的时候会有精度丢失的风险呢？"><a href="#2-为什么浮点数-float-或-double-运算的时候会有精度丢失的风险呢？" class="headerlink" title="2. 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？"></a>2. 为什么浮点数 float 或 double 运算的时候会有精度丢失的风险呢？</h2>计算机是二进制的，在表示一个数字时，<strong>宽度有限</strong>，无限循环的小数存储在计算机时，只能被<strong>截断</strong>，<h2 id="3-BigDecimal-常见方法"><a href="#3-BigDecimal-常见方法" class="headerlink" title="3. BigDecimal 常见方法"></a>3. BigDecimal 常见方法</h2></li>
</ol>
<ul>
<li>加减乘除：<code>add</code>、<code>subtract</code>、<code>multiply</code>、<code>divide</code></li>
<li>大小比较：<code>a.compareTo(b)</code></li>
<li>保留几位小数：<code>setScale</code><br><img src="https://img-blog.csdnimg.cn/737897a5fe46459391850bfd9ee563df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2>浮点数没有办法用二进制精确表示，因此存在<strong>精度丢失</strong>的风险。</li>
</ul>
<p>不过，Java 提供了<code>BigDecimal</code> 来操作浮点数。<code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>
<hr>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>本文档为个人方便自己熟记而整理，来自javaguide。<br>javaguide是个优秀的计算机知识整理：<a target="_blank" rel="noopener" href="https://javaguide.cn/">https://javaguide.cn/</a><br><img src="https://img-blog.csdnimg.cn/2b8f367dfd9f4e0da66ce99b35ebc4be.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r5bGx5Lio54Gs6JC957qi6Zuo,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">衣羊干洗</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2022/02/27/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/">http://example.com/2022/02/27/JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">衣羊干洗</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/JAVA/">
                                    <span class="chip bg-color">JAVA</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.png" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2022/03/05/Java%E5%AE%B9%E5%99%A8%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E3%80%81JVM/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/8.jpg" class="responsive-img" alt="Java容器、并发编程、JVM">
                        
                        <span class="card-title">Java容器、并发编程、JVM</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-03-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/JAVASE/" class="post-category">
                                    JAVASE
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/JAVA/">
                        <span class="chip bg-color">JAVA</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/02/02/Anaconda%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/6.jpg" class="responsive-img" alt="Anaconda安装及使用教程">
                        
                        <span class="card-title">Anaconda安装及使用教程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-02-02
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">
                                    深度学习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2022</span>
            
            <a href="/about" target="_blank">衣羊干洗</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://blog.csdn.net/qq_39493185" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: https://blog.csdn.net/qq_39493185" data-position="top" data-delay="50">
        <i class="fab fa-csdn">CSDN</i>
    </a>




    <a href="mailto:1426964415@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=https://qm.qq.com/cgi-bin/qm/qr?k=xWyN9XCQy2bTaeblPrhawThE1WY15Zpp&amp;noverify=0" class="tooltipped" target="_blank" data-tooltip="QQ联系我: https://qm.qq.com/cgi-bin/qm/qr?k=xWyN9XCQy2bTaeblPrhawThE1WY15Zpp&amp;noverify=0" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>





    <a href="https://www.zhihu.com/people/dian-zi-feng-zhuang-ji-zhu-luo-liang-a1" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/dian-zi-feng-zhuang-ji-zhu-luo-liang-a1" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>



</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
